<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self Chat</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f4f4f4;
            display: flex;
            justify-content: center;
            align-items: top;
            height: 120vh;
            margin: 0;
        }
        .chat-container {
            width: 100%;
            max-width: 675px;
            min-width: 450px;
            background: white;
            padding: 10px;
            box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow-x: auto;
            margin-left: 20px;
            margin-right: 20px;
        }
        .editable-title {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background: #f1f1f1;
            cursor: text;
        }
        .chat-box {
            height: calc(100vh - 230px);
            max-height: 600px;
            min-height: 150px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            background: #fafafa;
            display: flex;
            flex-direction: column;
            scroll-behavior: smooth;
            flex-grow: 0;
        }
        .chat-box div {
            margin: 3px 0;
            padding: 6px 10px;
            border-radius: 5px;
            max-width: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: text;
            text-align: left;
            background: #e6e6e6;
            color: black;
            cursor: pointer;
        }
        .user-msg {
            align-self: flex-start;
        }
        .timestamp {
            font-size: 10px;
            color: #555;
            margin-left: 8px;
        }
        .delete-btn {
            background: none;
            border: none;
            color: red;
            font-size: 9px;
            cursor: pointer;
            margin-left: 1px;
        }
        .delete-btn:hover {
            color: darkred;
        }
        .input-area, .controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .controls {
            flex-wrap: nowrap;
            overflow-x: auto;
            white-space: nowrap;
            padding-bottom: 5px;
        }
        textarea {
            flex: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            resize: none;
            overflow-y: hidden;
            min-height: 50px;
            max-height: 120px;
            font-size: 14px;
        }
        button, select {
            padding: 5px;
            border: none;
            background: #007bff;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            min-width: 50px;
            flex-shrink: 0;
        }
        button:hover, select:hover {
            background: #0056b3;
        }
        button[onclick="shareChat()"] {
            background: #00aced;
        }
        button[onclick="copySelectedMessages()"] {
            background: #ff9800; /* Orange for Copy */
        }
        button[onclick="pasteMessages()"] {
            background: #4caf50; /* Green for Paste */
        }
        button[onclick="clearChat()"] {
            background: #dc3545; /* Red for Clear */
        }
        button[onclick="clearChat()"]:hover {
            background: #c82333; /* Darker red on hover */
        }
        .chat-box div::selection {
            background: transparent;
            color: black;
        }
        .action-btn {
            background: none;
            border: none;
            color: #007bff;
            font-size: 12px;
            cursor: pointer;
            margin-left: 5px;
            padding: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            transition: background 0.2s;
        }
        .action-btn:hover {
            background: #f1f1f1;
        }
        .action-menu {
            display: none;
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.1);
            z-index: 1;
            right: 0;
            top: 100%;
            min-width: 80px;
        }
        .action-menu button {
            display: block;
            width: 100%;
            padding: 5px 10px;
            text-align: left;
            background: none;
            border: none;
            color: #333;
            cursor: pointer;
            font-size: 12px;
        }
        .action-menu button:hover {
            background: #f1f1f1;
        }
        .highlighted-yellow {
            background-color: yellow !important;
        }
        .highlighted-orange {
            background-color: orange !important;
        }
        .selected {
            background: #cce5ff !important; /* Light blue for selected messages */
            border: 1px solid #007bff;
        }
        .subtitle-dropdown {
            display: none;
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.1);
            z-index: 10;
            width: 200px;
            padding: 10px;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        .subtitle-dropdown input {
            width: 100%;
            padding: 5px;
            margin-bottom: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .subtitle-option {
            margin: 5px 0;
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
        }
        .subtitle-option:hover {
            background: #f1f1f1;
        }
        .subtitle-preset-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 3px;
            font-size: 12px;
        }
        .chat-box div.dragging {
            opacity: 0.5;
            background: #d3d3d3;
        }
        .chat-box div.drag-over {
            border: 2px dashed #007bff;
        }
        .subchat {
            margin-left: 30px !important;
            border-left: 2px solid #007bff;
            padding-left: 6px !important;
        }
        .checkbox-wrapper {
            display: inline-flex;
            align-items: center;
            margin-right: 5px;
        }
        .checkbox-wrapper input[type="checkbox"] {
            margin: 0 5px 0 0;
            cursor: pointer;
        }
        .toggle-subchat {
            background: none;
            border: none;
            color: #007bff;
            font-size: 14px;
            cursor: pointer;
            margin-right: 1px;
            padding: 0;
            width: 12px;
            min-width: 12px;
            text-align: center;
            vertical-align: middle;
            line-height: 1;
        }
        .toggle-subchat:hover {
            color: #0056b3;
        }
        .subchat-hidden {
            display: none !important;
        }
        .chat-container.drag-over {
            background: #e0e0e0; /* Visual feedback for external drop */
        }

/* Add these to your existing styles */
button[onclick="syncAcrossDevices()"] {
    background: #ff9800 !important; /* Orange for Sync */
}

button[onclick="syncAcrossDevices()"]:hover {
    background: #e68900 !important; /* Darker orange on hover */
}

button[onclick="copySyncLink()"] {
    background: #ff9800 !important; /* Orange for Copy Link */
}

button[onclick="copySyncLink()"]:hover {
    background: #e68900 !important; /* Darker orange on hover */
}

    </style>
</head>
<body>

<div class="chat-container">
    <div id="chatTitle" class="editable-title" contenteditable="true">Title</div>
    <input type="text" id="searchInput" placeholder="üîç Search messages..." oninput="filterMessages()">
    <div class="chat-box" id="chatBox"></div>
    <div class="input-area">
        <textarea id="textInput" placeholder="Type a message..." oninput="autoExpand(this)"></textarea>
        <button onclick="sendMessage()" style="color:white;background-color:green;">Send</button>
    </div>
<div class="controls">
    <button onclick="copySelectedMessages()" title="Copy selected messages to clipboard">üìã Copy</button>
    <button onclick="pasteMessages()" title="Paste messages from clipboard or app">üì• Paste</button>
    <button id="subtitleBtn" onclick="toggleSubtitleDropdown()" style="color:white;background-color:gray;" title="Insert more subtitles for different sections">‚ûï Sub</button>
    <select id="viewVersion" onchange="handleViewChange()" style="width:85px;color:white;background-color:blue;">
        <option value="">üåê View</option>
        <option value="v5">V5(Clean)</option>
        <option value="v1">V1(bullet)</option>
        <option value="v2">V2</option>
        <option value="v3">V3(Single ‚Ä¢)</option>
        <option value="v4">V4(Checkboxes)</option>
    </select>
    <button onclick="saveChatAsFile()" style="color:white;background-color:purple;" title="Save as a txt file on Disk">üíæ Save</button>
    <button onclick="openChatFile()" style="color:white;background-color:orange;" title="Open a saved txt file from Disk">üìÇ Open</button>
    <button onclick="syncAcrossDevices()" style="color:white;background-color:orange;" title="Sync chat across devices">üîÑ Sync</button>
    <button onclick="copySyncLink()" style="color:white;background-color:#ff9800;display:none;" id="copyLinkBtn" title="Copy sync link to clipboard">üìã Copy Link</button>
    <button onclick="exportToGmail()" style="color:white;background-color:green;" title="Send the contexts to your gmail account">‚úâÔ∏è Gmail</button>
    <!-- NEW: Dynalist buttons -->
    <button onclick="sendToDynalist()" style="color:white;background-color:#8e44ad;" title="Export to Dynalist">üìù Dynalist</button>
    <button onclick="showDynalistSettings()" style="color:white;background-color:#9b59b6;" title="Dynalist Settings">‚öôÔ∏è Dynalist</button>
    <button onclick="shareChat()" style="color:white;background-color:#00aced;" title="Share chat to other apps">üì§ Share</button>
    <button onclick="clearChat()" style="color:white;background-color:red;" title="Clear all chat contents">üóëÔ∏è Clear</button>
</div>
    <div>
        <footer>
            Copyright ¬© 2025 Dr. Wen-Ming Yang 20251007:  v2.09T9 <br>
            20251007: v209T9: Export to Dynalist.
            20250828: v209T8d: Synchronize with other devices.
            20250730: v209T8c: View with true popout windon with the same size of container<br>
            20250404: v209T8b: Save function will be like autosove (working for Chrome only)<br>
            
<!--        20250404: v209T8: Autosaving function (1 hour off)+Title today.<br>
            20250312: v209T7: Add Clear button and 2nd highlight color orange.<br>
            20250311: v209T6: Subtitle popout window is centered.<br>
            20250311: v209T5: Added cross-window drag-and-drop for multiple selected messages.<br>
            20250309: v209T4: Drag/drop from the saved .txt items to the chatbox. <br>
            20250306: v209T3: Make Voice button hidden for a better usage.<br>
            20250305: v209T2: Add copy/paste function for cross windows. <br>
            20250305: v209T1: Add copy/paste function. But only for same window, not for cross windows.<br>
            (from 204) Resize with window 1.5/double-clicking for subchat + Toggle
 -->           
        </footer>
    </div>
</div>

<div id="subtitleDropdown" class="subtitle-dropdown">
    <div>Custom Subtitles:</div>
    <input type="text" id="customSubtitle" placeholder="Enter custom subtitle text">
    <button onclick="insertCustomSubtitle()" style="width:100%;margin-bottom:10px;">Insert Custom</button>   
    <button onclick="addNewPreset()" style="width:100%;margin-top:10px;">Add to Presets</button>
    <div class="subtitle-preset-list">
        <div class="subtitle-option" onclick="insertSubtitlePreset('<<< NextPart >>>')"><<< NextPart >>></div>
        <div class="subtitle-option" onclick="insertSubtitlePreset('<<< Review & Recap >>>')"><<< Review & Recap >>></div>
        <div class="subtitle-option" onclick="insertSubtitlePreset('<<< OfficeStart >>>')"><<< OfficeStart >>></div>
        <div class="subtitle-option" onclick="insertSubtitlePreset('Summary: ')">Summary</div>
        <div class="subtitle-option" onclick="insertSubtitlePreset('Next-to-do: ')">Next-to-do</div>
        <div class="subtitle-option" onclick="insertSubtitlePreset('<<< Home hours >>>')"><<< Home hours >>></div>
        <div class="subtitle-option" onclick="insertSubtitlePreset('--- NewSection ---')">--- New Section ---</div>
        <div class="subtitle-option" onclick="insertSubtitlePreset('===== Subtitle =====')">===== Subtitle =====</div>
        <div class="subtitle-option" onclick="insertSubtitlePreset('!!! Review & Relcoate !!!')">!!! Review & Relcoate !!!</div>
        <div class="subtitle-option" onclick="insertSubtitlePreset('!!! What Next? !!!')">!!! What Next? !!!</div>
        <div class="subtitle-option" onclick="insertSubtitlePreset('*** important')">*** Important</div>
        <div class="subtitle-option" onclick="insertSubtitlePreset('!!! Warning')">!!! Warning</div>
        <div class="subtitle-option" onclick="insertSubtitlePreset('‚ñº‚ñº‚ñº TopicChange ‚ñº‚ñº‚ñº')">‚ñº‚ñº‚ñº Topic Change ‚ñº‚ñº‚ñº</div>
        <div class="subtitle-option" onclick="insertSubtitlePreset('### Chapter ###')">### Chapter ###</div>
    </div>
</div>

<script>
    let selectedMessages = new Set(); // To store selected message elements
    let messageClipboard = []; // To store copied messages within the app
    let draggedElement = null;

    function scrollToBottom(element) {
        element.offsetHeight;
        element.scrollTop = element.scrollHeight;
    }

    document.addEventListener("DOMContentLoaded", function() {
        document.getElementById("textInput").addEventListener("keydown", function(event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        });
        
        document.addEventListener("click", function(event) {
            const dropdown = document.getElementById("subtitleDropdown");
            const subtitleBtn = document.getElementById("subtitleBtn");
            if (!dropdown.contains(event.target) && event.target !== subtitleBtn) {
                dropdown.style.display = "none";
            }
            // Clear selection if clicking outside a message
            if (!event.target.closest(".user-msg") && !(event.ctrlKey || event.metaKey)) {
                selectedMessages.forEach(msg => msg.classList.remove("selected"));
                selectedMessages.clear();
            }
        });

        const chatBox = document.getElementById("chatBox");
        chatBox.addEventListener("dragstart", handleDragStart);
        chatBox.addEventListener("dragover", handleDragOver);
        chatBox.addEventListener("drop", handleDrop);
        chatBox.addEventListener("dragend", handleDragEnd);

        // Visual feedback for external text drops on chatBox
        chatBox.addEventListener("dragover", (event) => {
            event.preventDefault();
            if (event.dataTransfer.types.includes("text/plain") && !draggedElement) {
                event.dataTransfer.dropEffect = "copy";
                chatBox.style.background = "#e0e0e0";
            }
        });
        chatBox.addEventListener("dragleave", () => {
            chatBox.style.background = "#fafafa";
        });

        const chatContainer = document.querySelector(".chat-container");
        chatContainer.addEventListener("dragover", (event) => {
            event.preventDefault();
            chatContainer.classList.add("drag-over");
        });
        chatContainer.addEventListener("dragleave", () => {
            chatContainer.classList.remove("drag-over");
        });
        chatContainer.addEventListener("drop", (event) => {
            event.preventDefault();
            chatContainer.classList.remove("drag-over");
            const files = event.dataTransfer.files;
            if (files && files.length > 0) {
                if (files[0].type === "text/plain") {
                    loadDroppedFile(files[0]);
                } else {
                    alert("Please drop a valid .txt file.");
                }
            } else {
                handleDrop(event); // Handle text drops
            }
        });
    });

    window.addEventListener('resize', function() {
        const chatContainer = document.querySelector('.chat-container');
        const windowWidth = window.innerWidth;
        chatContainer.style.width = Math.min(Math.max(windowWidth, 450), 675) + 'px';
    });

    window.dispatchEvent(new Event('resize'));

    function loadDroppedFile(file) {
        const reader = new FileReader();
        reader.onload = function () {
            const lines = reader.result.split("\n");
            document.getElementById("chatTitle").textContent = lines[0].trim();
            const chatBox = document.getElementById("chatBox");
            chatBox.innerHTML = "";

            lines.slice(2).forEach(line => {
                const match = line.match(/(  ‚Ä¢|‚Ä¢) (\[H\]\s)?(.*?) \((\d+:\d+ [APM]{2})\)/);
                if (match) {
                    const isSubchat = match[1] === "  ‚Ä¢";
                    const isHighlighted = !!match[2];
                    let text = match[3];
                    const timestamp = match[4];

                    text = text.replace(/\[X\]/g, '<span class="checkbox-wrapper"><input type="checkbox" checked></span>')
                               .replace(/\[ \]/g, '<span class="checkbox-wrapper"><input type="checkbox"></span>');

                    const newMessage = sendMessage(text, timestamp, true);
                    if (isSubchat) newMessage.classList.add("subchat");
                    if (isHighlighted) newMessage.classList.add("highlighted-yellow");
                }
            });

            requestAnimationFrame(() => {
                scrollToBottom(chatBox);
                updateSubchatToggles();
            });
        };
        reader.readAsText(file);
    }

    function autoExpand(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
    }

    function sendMessage(message = null, timestamp = null, isFromFile = false) {
        let inputField = document.getElementById("textInput");
        let chatBox = document.getElementById("chatBox");

        let text = message || inputField.value.trim();
        if (text === "") return;

        let time = timestamp || getCurrentTime();
        let userMessage = document.createElement("div");
        userMessage.classList.add("user-msg");
        userMessage.contentEditable = true;
        userMessage.draggable = true;

        let messageText = text.replace(/\[\]/g, '<span class="checkbox-wrapper"><input type="checkbox"> </span>');
        userMessage.innerHTML = `<span class="message-text">${messageText}</span> <span class="timestamp">${time}</span>`;

        let isSubchat = false;
        if (!isFromFile) {
            let lastMessage = chatBox.lastElementChild;
            if (lastMessage && lastMessage.classList.contains("subchat")) {
                userMessage.classList.add("subchat");
                isSubchat = true;
            }
        }

        let actionBtn = document.createElement("button");
        actionBtn.innerHTML = "‚öôÔ∏è";
        actionBtn.classList.add("action-btn");

        let actionMenu = document.createElement("div");
        actionMenu.classList.add("action-menu");
        actionMenu.style.display = "none";

        let highlightYellowOption = document.createElement("button");
        highlightYellowOption.innerHTML = "Highlight (Yellow)";
        highlightYellowOption.onclick = function () {
            toggleHighlight(userMessage, "yellow");
        };

        let highlightOrangeOption = document.createElement("button");
        highlightOrangeOption.innerHTML = "Highlight (Orange)";
        highlightOrangeOption.onclick = function () {
            toggleHighlight(userMessage, "orange");
        };

        let deleteOption = document.createElement("button");
        deleteOption.innerHTML = "Delete";
        deleteOption.onclick = function () {
            chatBox.removeChild(userMessage);
            updateSubchatToggles();
        };

        let subchatOption = document.createElement("button");
        subchatOption.innerHTML = "Shift to Subchat";
        subchatOption.onclick = function () {
            shiftToSubchat(userMessage);
            updateSubchatToggles();
        };

        actionMenu.appendChild(highlightYellowOption);
        actionMenu.appendChild(highlightOrangeOption);
        actionMenu.appendChild(deleteOption);
        actionMenu.appendChild(subchatOption);
        actionBtn.appendChild(actionMenu);

        actionBtn.onclick = function (event) {
            event.stopPropagation();
            actionMenu.style.display = actionMenu.style.display === "block" ? "none" : "block";
        };

        document.addEventListener("click", function (event) {
            if (!actionBtn.contains(event.target)) {
                actionMenu.style.display = "none";
            }
        });

        userMessage.appendChild(actionBtn);

        if (!isSubchat) {
            let toggleBtn = document.createElement("button");
            toggleBtn.innerHTML = "+";
            toggleBtn.classList.add("toggle-subchat");
            toggleBtn.style.visibility = "hidden";
            toggleBtn.onclick = (event) => {
                event.stopPropagation();
                toggleSubchats(userMessage);
            };
            userMessage.insertBefore(toggleBtn, userMessage.firstChild);
        }

        chatBox.appendChild(userMessage);

        if (isSubchat && !isFromFile) {
            const allMessages = Array.from(chatBox.children);
            const prevMessage = allMessages[allMessages.length - 2]; // Message before this one
            if (prevMessage && prevMessage.querySelector(".toggle-subchat")?.innerHTML === "+") {
                userMessage.classList.add("subchat-hidden");
            }
        }

        userMessage.addEventListener("click", function (event) {
            if (event.ctrlKey || event.metaKey) { // Ctrl or Cmd for multi-select
                event.preventDefault();
                toggleMessageSelection(userMessage);
            }
        });

        userMessage.addEventListener("dblclick", function (event) {
            if (event.target === actionBtn || actionMenu.contains(event.target)) return;
            shiftToSubchat(userMessage);
            updateSubchatToggles();
            event.preventDefault();
        });

        if (!isFromFile) {
            inputField.value = "";
            autoExpand(inputField);
        }

        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                scrollToBottom(chatBox);
                updateSubchatToggles();
            });
        });

        return userMessage;
    }

    function getCurrentTime() {
        let now = new Date();
        let hours = now.getHours();
        let minutes = now.getMinutes();
        let ampm = hours >= 12 ? "PM" : "AM";
        hours = hours % 12 || 12;
        minutes = minutes.toString().padStart(2, "0");
        return `${hours}:${minutes} ${ampm}`;
    }

    function shiftToSubchat(messageElement) {
        const chatBox = document.getElementById("chatBox");
        const allMessages = Array.from(chatBox.children);
        const messageIndex = allMessages.indexOf(messageElement);

        if (messageElement.classList.contains("subchat")) {
            messageElement.classList.remove("subchat");
            messageElement.classList.remove("subchat-hidden");

            const existingToggle = messageElement.querySelector(".toggle-subchat");
            if (existingToggle) {
                messageElement.removeChild(existingToggle);
            }

            let hasSubchats = false;
            let subchatGroup = [];
            for (let i = messageIndex + 1; i < allMessages.length; i++) {
                if (allMessages[i].classList.contains("subchat")) {
                    hasSubchats = true;
                    subchatGroup.push(allMessages[i]);
                } else {
                    break;
                }
            }

            if (hasSubchats) {
                let toggleBtn = document.createElement("button");
                toggleBtn.innerHTML = "‚àí";
                toggleBtn.classList.add("toggle-subchat");
                toggleBtn.style.visibility = "visible";
                toggleBtn.onclick = (event) => {
                    event.stopPropagation();
                    toggleSubchats(messageElement);
                };
                messageElement.insertBefore(toggleBtn, messageElement.firstChild);
                subchatGroup.forEach(subchat => subchat.classList.remove("subchat-hidden"));
            }
        } else {
            messageElement.classList.add("subchat");
            messageElement.classList.remove("subchat-hidden");
            const existingToggle = messageElement.querySelector(".toggle-subchat");
            if (existingToggle) {
                messageElement.removeChild(existingToggle);
            }
        }
    }

    function toggleSubchats(message) {
        const chatBox = document.getElementById("chatBox");
        const allMessages = Array.from(chatBox.children);
        const messageIndex = allMessages.indexOf(message);
        const toggleBtn = message.querySelector(".toggle-subchat");

        if (!toggleBtn) return;

        let subchatGroup = [];
        for (let i = messageIndex + 1; i < allMessages.length; i++) {
            if (allMessages[i].classList.contains("subchat")) {
                subchatGroup.push(allMessages[i]);
            } else {
                break;
            }
        }

        if (subchatGroup.length > 0) {
            const isCollapsed = toggleBtn.innerHTML === "+";
            toggleBtn.innerHTML = isCollapsed ? "‚àí" : "+";
            subchatGroup.forEach(subchat => {
                if (isCollapsed) {
                    subchat.classList.remove("subchat-hidden");
                } else {
                    subchat.classList.add("subchat-hidden");
                }
            });
            toggleBtn.style.visibility = "visible";
        }
    }

    function updateSubchatToggles() {
        const chatBox = document.getElementById("chatBox");
        const allMessages = Array.from(chatBox.children);

        allMessages.forEach((message, index) => {
            const toggleBtn = message.querySelector(".toggle-subchat");
            let hasSubchats = false;
            let subchatGroup = [];

            for (let i = index + 1; i < allMessages.length; i++) {
                if (allMessages[i].classList.contains("subchat")) {
                    hasSubchats = true;
                    subchatGroup.push(allMessages[i]);
                } else {
                    break;
                }
            }

            if (message.classList.contains("subchat")) {
                if (toggleBtn) {
                    message.removeChild(toggleBtn);
                }
            } else {
                if (toggleBtn) {
                    if (hasSubchats) {
                        toggleBtn.style.visibility = "visible";
                        const isCollapsed = toggleBtn.innerHTML === "+";
                        subchatGroup.forEach(subchat => {
                            subchat.classList.toggle("subchat-hidden", isCollapsed);
                        });
                    } else {
                        toggleBtn.style.visibility = "hidden";
                        toggleBtn.innerHTML = "+";
                    }
                } else if (hasSubchats) {
                    let newToggleBtn = document.createElement("button");
                    newToggleBtn.innerHTML = "‚àí";
                    newToggleBtn.classList.add("toggle-subchat");
                    newToggleBtn.style.visibility = "visible";
                    newToggleBtn.onclick = (event) => {
                        event.stopPropagation();
                        toggleSubchats(message);
                    };
                    message.insertBefore(newToggleBtn, message.firstChild);
                    subchatGroup.forEach(subchat => subchat.classList.remove("subchat-hidden"));
                }
            }
        });
    }

    function toggleMessageSelection(messageElement) {
        if (selectedMessages.has(messageElement)) {
            selectedMessages.delete(messageElement);
            messageElement.classList.remove("selected");
        } else {
            selectedMessages.add(messageElement);
            messageElement.classList.add("selected");
        }
    }

    function toggleHighlight(messageElement, color) {
        const isYellow = messageElement.classList.contains("highlighted-yellow");
        const isOrange = messageElement.classList.contains("highlighted-orange");

        if (color === "yellow") {
            if (isYellow) {
                messageElement.classList.remove("highlighted-yellow");
            } else {
                messageElement.classList.remove("highlighted-orange");
                messageElement.classList.add("highlighted-yellow");
            }
        } else if (color === "orange") {
            if (isOrange) {
                messageElement.classList.remove("highlighted-orange");
            } else {
                messageElement.classList.remove("highlighted-yellow");
                messageElement.classList.add("highlighted-orange");
            }
        }
    }

    function copySelectedMessages() {
        if (selectedMessages.size === 0) {
            alert("No messages selected to copy.");
            return;
        }

        const selectionCount = selectedMessages.size;

        messageClipboard = Array.from(selectedMessages).map(msg => ({
            text: msg.querySelector(".message-text").innerHTML,
            timestamp: msg.querySelector(".timestamp").textContent,
            isSubchat: msg.classList.contains("subchat"),
            isHighlighted: msg.classList.contains("highlighted-yellow") || msg.classList.contains("highlighted-orange")
        }));

        const clipboardText = Array.from(selectedMessages).map(msg => {
            let textSpan = msg.querySelector(".message-text");
            let timestamp = msg.querySelector(".timestamp");
            let prefix = msg.classList.contains("subchat") ? "  ‚Ä¢" : "‚Ä¢";
            let highlightMarker = msg.classList.contains("highlighted-yellow") || msg.classList.contains("highlighted-orange") ? "[H] " : "";
            let clonedSpan = textSpan.cloneNode(true);
            let checkboxes = clonedSpan.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                let replacement = cb.checked ? '[X]' : '[ ]';
                let span = cb.parentElement;
                span.outerHTML = replacement;
            });
            return `${prefix} ${highlightMarker}${clonedSpan.textContent} (${timestamp.textContent})`;
        }).join("\n");

        navigator.clipboard.writeText(clipboardText)
            .then(() => {
                selectedMessages.forEach(msg => msg.classList.remove("selected"));
                selectedMessages.clear();
                alert(`${selectionCount} message(s) copied to clipboard. You can paste them in another window or app.`);
            })
            .catch(err => {
                console.error('Failed to copy to clipboard: ', err);
                alert('Copy failed. Please try again.');
            });
    }

    function pasteMessages() {
        const chatBox = document.getElementById("chatBox");
        let targetMessage = null;

        if (selectedMessages.size === 1) {
            targetMessage = Array.from(selectedMessages)[0];
            selectedMessages.clear();
            targetMessage.classList.remove("selected");
        }

        if (messageClipboard.length > 0) {
            messageClipboard.forEach(msgData => {
                const newMessage = sendMessage(msgData.text, msgData.timestamp, true);
                if (msgData.isSubchat) newMessage.classList.add("subchat");
                if (msgData.isHighlighted) newMessage.classList.add("highlighted-yellow");

                if (targetMessage) {
                    targetMessage.after(newMessage);
                    targetMessage = newMessage;
                } else {
                    chatBox.appendChild(newMessage);
                }
            });

            requestAnimationFrame(() => {
                scrollToBottom(chatBox);
                updateSubchatToggles();
            });

            alert(`${messageClipboard.length} message(s) pasted from app clipboard.`);
            return;
        }

        navigator.clipboard.readText()
            .then(text => {
                if (!text.trim()) {
                    alert("Clipboard is empty or contains no valid text.");
                    return;
                }

                const lines = text.split("\n");
                let pastedCount = 0;

                lines.forEach(line => {
                    const match = line.match(/(  ‚Ä¢|‚Ä¢) (\[H\]\s)?(.*?) \((\d+:\d+ [APM]{2})\)/);
                    if (match) {
                        const isSubchat = match[1] === "  ‚Ä¢";
                        const isHighlighted = !!match[2];
                        let messageText = match[3];
                        const timestamp = match[4];

                        const newMessage = sendMessage(messageText, timestamp, true);
                        if (isSubchat) newMessage.classList.add("subchat");
                        if (isHighlighted) newMessage.classList.add("highlighted-yellow");

                        if (targetMessage) {
                            targetMessage.after(newMessage);
                            targetMessage = newMessage;
                        } else {
                            chatBox.appendChild(newMessage);
                        }
                        pastedCount++;
                    }
                });

                if (pastedCount > 0) {
                    requestAnimationFrame(() => {
                        scrollToBottom(chatBox);
                        updateSubchatToggles();
                    });
                    alert(`${pastedCount} message(s) pasted from system clipboard.`);
                } else {
                    alert("No valid chat messages found in clipboard.");
                }
            })
            .catch(err => {
                console.error('Failed to read clipboard: ', err);
                alert('Paste failed. Please ensure clipboard contains valid chat messages.');
            });
    }

    function saveChatAsFile() {
        let chatTitle = document.getElementById("chatTitle").textContent.trim();
        let messages = Array.from(document.getElementById("chatBox").children).map(div => {
            let textSpan = div.querySelector(".message-text");
            let timestamp = div.querySelector(".timestamp");
            let prefix = div.classList.contains("subchat") ? "  ‚Ä¢" : "‚Ä¢";
            let highlightMarker = div.classList.contains("highlighted-yellow") || div.classList.contains("highlighted-orange") ? "[H] " : "";

            if (!textSpan) return "";

            let clonedSpan = textSpan.cloneNode(true);
            let checkboxes = clonedSpan.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                let replacement = cb.checked ? '[X]' : '[ ]';
                let span = cb.parentElement;
                span.outerHTML = replacement;
            });
            let messageText = clonedSpan.textContent;

            return `${prefix} ${highlightMarker}${messageText} (${timestamp.textContent})`;
        });

        if (messages.length === 0) {
            alert("No chat history to save.");
            return;
        }

        let chatText = chatTitle + "\n\n" + messages.join("\n");
        let blob = new Blob([chatText], { type: "text/plain" });
        let fileName = prompt("Enter file name:", chatTitle || "chat_history");
        if (!fileName) return;

        let link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = fileName + ".txt";
        link.click();
    }

    function openChatFile() {
        let input = document.createElement("input");
        input.type = "file";
        input.accept = ".txt";
        input.onchange = function (event) {
            let file = event.target.files[0];
            if (!file) return;

            let reader = new FileReader();
            reader.onload = function () {
                let lines = reader.result.split("\n");
                document.getElementById("chatTitle").textContent = lines[0].trim();

                let chatBox = document.getElementById("chatBox");
                chatBox.innerHTML = "";

                lines.slice(2).forEach(line => {
                    let match = line.match(/(  ‚Ä¢|‚Ä¢) (\[H\]\s)?(.*?) \((\d+:\d+ [APM]{2})\)/);
                    if (match) {
                        let isSubchat = match[1] === "  ‚Ä¢";
                        let isHighlighted = !!match[2];
                        let text = match[3];
                        let timestamp = match[4];

                        text = text.replace(/\[X\]/g, '<span class="checkbox-wrapper"><input type="checkbox" checked></span>')
                                   .replace(/\[ \]/g, '<span class="checkbox-wrapper"><input type="checkbox"></span>');

                        let newMessage = sendMessage(text, timestamp, true);
                        if (isSubchat) newMessage.classList.add("subchat");
                        if (isHighlighted) newMessage.classList.add("highlighted-yellow");
                    }
                });

                requestAnimationFrame(() => {
                    scrollToBottom(chatBox);
                    updateSubchatToggles();
                });
            };
            reader.readAsText(file);
        };
        input.click();
    }

    function exportToGmail() {
        let chatTitle = document.getElementById("chatTitle").textContent.trim();
        let messages = Array.from(document.getElementById("chatBox").children).map(div => {
            let textSpan = div.querySelector(".message-text");
            let timestamp = div.querySelector(".timestamp");
            let prefix = div.classList.contains("subchat") ? "  ‚Ä¢" : "‚Ä¢";
            let highlightMarker = div.classList.contains("highlighted-yellow") || div.classList.contains("highlighted-orange") ? "[H] " : "";

            if (!textSpan) return "";

            let clonedSpan = textSpan.cloneNode(true);
            let checkboxes = clonedSpan.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                let replacement = cb.checked ? '[X]' : '[ ]';
                let span = cb.parentElement;
                span.outerHTML = replacement;
            });
            let messageText = clonedSpan.textContent;

            return `${prefix} ${highlightMarker}${messageText} (${timestamp.textContent})`;
        });

        if (messages.length === 0) {
            alert("No chat history to export.");
            return;
        }

        let chatText = chatTitle + "\n\n" + messages.join("\n");
        let subject = encodeURIComponent(`Chat Export: ${chatTitle}`);
        let body = encodeURIComponent(chatText);
        let to = encodeURIComponent('yangwm@email.nchu.edu.tw');
        let gmailUrl = `https://mail.google.com/mail/?view=cm&fs=1&to=${to}&su=${subject}&body=${body}`;
        window.open(gmailUrl, "Gmail", "width=600,height=600");
    }

    function filterMessages() {
        let query = document.getElementById("searchInput").value.toLowerCase();
        document.querySelectorAll(".chat-box div").forEach(msg => {
            msg.style.display = msg.textContent.toLowerCase().includes(query) ? "block" : "none";
        });
    }

function openChatInNewWindow() {
    let chatTitle = document.getElementById("chatTitle").textContent.trim();
    let container = document.querySelector('.chat-container');
    let width = container.offsetWidth + 40;  // add padding/margin if needed
    let height = container.offsetHeight + 60;

    let messages = Array.from(document.getElementById("chatBox").children).map(div => {
        let textSpan = div.querySelector(".message-text");
        let timestamp = div.querySelector(".timestamp");
        let isSubchat = div.classList.contains("subchat");
        let isYellow = div.classList.contains("highlighted-yellow");
        let isOrange = div.classList.contains("highlighted-orange");

        let classAttr = '';
        if (isYellow) classAttr += ' highlighted-yellow';
        if (isOrange) classAttr += ' highlighted-orange';
        if (isSubchat) classAttr += ' subchat';

        if (!textSpan) return "";

        let messageContent = textSpan.innerHTML;
        return `<p class="${classAttr.trim()}">‚Ä¢ ${messageContent} <small>(${timestamp.textContent})</small></p>`;
    }).join("");

    if (!messages) {
        alert("No chat history to display.");
        return;
    }

    let newWindow = window.open("", "_blank", `width=${width},height=${height},left=100,top=100,resizable=yes,scrollbars=yes`);

    newWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
            <title>${chatTitle}</title>
            <meta charset="UTF-8">
            <style>
                body { font-family: Arial, sans-serif; padding: 20px; background: #f4f4f4; }
                h2 { text-align: center; }
                .chat-box { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 0 6px rgba(0,0,0,0.1); }
                p { background: #e6e6e6; padding: 8px; border-radius: 5px; margin: 5px 0; }
                p.highlighted-yellow { background: yellow; }
                p.highlighted-orange { background: orange; }
                p.subchat { margin-left: 10px; border-left: 2px solid #007bff; padding-left: 6px; }
                small { color: #555; font-size: 12px; }
            </style>
        </head>
        <body>
            <h2>${chatTitle}</h2>
            <div class="chat-box">${messages}</div>
        </body>
        </html>
    `);
}


    function openChatInNewWindow2() {
        let chatTitle = document.getElementById("chatTitle").textContent.trim();
        let messages = Array.from(document.getElementById("chatBox").children).map(div => {
            let textSpan = div.querySelector(".message-text");
            let timestamp = div.querySelector(".timestamp");
            let isSubchat = div.classList.contains("subchat");
            let isYellowHighlighted = div.classList.contains("highlighted-yellow");
            let isOrangeHighlighted = div.classList.contains("highlighted-orange");
            let classAttr = isYellowHighlighted ? ' class="highlighted-yellow' + (isSubchat ? ' subchat' : '') + '"' : 
                            isOrangeHighlighted ? ' class="highlighted-orange' + (isSubchat ? ' subchat' : '') + '"' : 
                            (isSubchat ? ' class="subchat"' : '');

            if (!textSpan) return "";

            let messageContent = textSpan.innerHTML;
            return `<p${classAttr}>${messageContent} <small>(${timestamp.textContent})</small></p>`;
        }).join("");

        if (messages === "") {
            alert("No chat history to display.");
            return;
        }

let container = document.querySelector('.chat-container');
let width = container.offsetWidth + 40;  // add some margin
let height = container.offsetHeight + 60;
let newWindow = window.open("", "_blank", `width=${width},height=${height},left=100,top=100,resizable=yes,scrollbars=yes`);

        newWindow.document.write(`
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>${chatTitle}</title>
                <style>
                    body { font-family: Arial, sans-serif; padding: 20px; background: #f4f4f4; }
                    h2 { text-align: center; color: #333; }
                    .chat-box { background: white; padding: 15px; border-radius: 8px; box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.1); }
                    p { font-size: 14px; color: #333; background: #e6e6e6; padding: 8px; border-radius: 5px; margin: 5px 0; }
                    p.highlighted-yellow { background: yellow; }
                    p.highlighted-orange { background: orange; }
                    p.subchat { margin-left: 10px; border-left: 2px solid #007bff; padding-left: 6px; }
                    small { color: #555; font-size: 12px; }
                    .checkbox-wrapper { display: inline-flex; align-items: center; margin-right: 5px; }
                    .checkbox-wrapper input[type="checkbox"] { margin: 0 5px 0 0; cursor: pointer; }
                </style>
            </head>
            <body>
                <h2>${chatTitle}</h2>
                <div class="chat-box">${messages}</div>
            </body>
            </html>
        `);
    }

    function openChatInNewWindow3() {
        let chatTitle = document.getElementById("chatTitle").textContent.trim();
        let messages = Array.from(document.getElementById("chatBox").children).map(div => {
            let textSpan = div.querySelector(".message-text");
            let timestamp = div.querySelector(".timestamp");
            let prefix = div.classList.contains("subchat") ? "  ‚Ä¢" : "‚Ä¢";
            let highlightMarker = div.classList.contains("highlighted-yellow") || div.classList.contains("highlighted-orange") ? "[H] " : "";

            if (!textSpan) return "";

            let clonedSpan = textSpan.cloneNode(true);
            let checkboxes = clonedSpan.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                let replacement = cb.checked ? '[X]' : '[ ]';
                let span = cb.parentElement;
                span.outerHTML = replacement;
            });
            let messageText = clonedSpan.textContent;

            return `${prefix} ${highlightMarker}${messageText} (${timestamp.textContent})`;
        }).join("\n");

        if (messages === "") {
            alert("No chat history to display.");
            return;
        }

let container = document.querySelector('.chat-container');
let width = container.offsetWidth + 40;  // add some margin
let height = container.offsetHeight + 60;
let newWindow = window.open("", "_blank", `width=${width},height=${height},left=100,top=100,resizable=yes,scrollbars=yes`);

        newWindow.document.write(`
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>${chatTitle}</title>
                <style>
                    body { font-family: Arial, sans-serif; padding: 20px; background: #f4f4f4; }
                    h2 { text-align: center; color: #333; }
                    .chat-box { background: white; padding: 15px; border-radius: 8px; box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.1); white-space: pre-wrap; }
                </style>
            </head>
            <body>
                <h2>${chatTitle}</h2>
                <div class="chat-box">${messages}</div>
            </body>
            </html>
        `);
    }

    function openChatInNewWindow4() {
        let chatTitle = document.getElementById("chatTitle").textContent.trim();
        let messages = Array.from(document.getElementById("chatBox").children).map(div => {
            let textSpan = div.querySelector(".message-text");
            let timestamp = div.querySelector(".timestamp");
            let prefix = div.classList.contains("subchat") ? "  ‚Ä¢" : "‚Ä¢";
            let highlightMarker = div.classList.contains("highlighted-yellow") || div.classList.contains("highlighted-orange") ? "[H] " : "";

            if (!textSpan) return "";

            let clonedSpan = textSpan.cloneNode(true);
            let messageText = clonedSpan.innerHTML;

            return `${prefix} ${highlightMarker}${messageText} (${timestamp.textContent})`;
        }).join("\n");

        if (messages === "") {
            alert("No chat history to display.");
            return;
        }

let container = document.querySelector('.chat-container');
let width = container.offsetWidth + 40;  // add some margin
let height = container.offsetHeight + 60;
let newWindow = window.open("", "_blank", `width=${width},height=${height},left=100,top=100,resizable=yes,scrollbars=yes`);

        newWindow.document.write(`
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>${chatTitle}</title>
                <style>
                    body { font-family: Arial, sans-serif; padding: 20px; background: #f4f4f4; }
                    h2 { text-align: center; color: #333; }
                    .chat-box { background: white; padding: 15px; border-radius: 8px; box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.1); white-space: pre-wrap; }
                    .checkbox-wrapper { display: inline-flex; align-items: center; margin-right: 5px; }
                    .checkbox-wrapper input[type="checkbox"] { margin: 0 5px 0 0; cursor: pointer; }
                </style>
            </head>
            <body>
                <h2>${chatTitle}</h2>
                <div class="chat-box">${messages}</div>
            </body>
            </html>
        `);
    }

function openChatInNewWindow5() {
    let chatTitle = document.getElementById("chatTitle").textContent.trim();
    let container = document.querySelector('.chat-container');
    let width = container.offsetWidth + 40;
    let height = container.offsetHeight + 60;

    let messages = Array.from(document.getElementById("chatBox").children).map(div => {
        let textSpan = div.querySelector(".message-text");
        let timestamp = div.querySelector(".timestamp");
        let isSubchat = div.classList.contains("subchat");
        let isYellow = div.classList.contains("highlighted-yellow");
        let isOrange = div.classList.contains("highlighted-orange");

        let classAttr = '';
        if (isYellow) classAttr += ' highlighted-yellow';
        if (isOrange) classAttr += ' highlighted-orange';
        if (isSubchat) classAttr += ' subchat';

        if (!textSpan) return "";

        let messageContent = textSpan.innerHTML;
        return `<div class="user-msg${classAttr}">${messageContent} <span class="timestamp">${timestamp.textContent}</span></div>`;
    }).join("");

    if (!messages) {
        alert("No chat content to show.");
        return;
    }

    let newWindow = window.open("", "_blank", `width=${width},height=${height},left=100,top=100,resizable=yes,scrollbars=yes`);

    newWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
            <title>${chatTitle}</title>
            <meta charset="UTF-8">
            <style>
                body {
                    font-family: Arial, sans-serif;
                    background: #f4f4f4;
                    margin: 0;
                    padding: 20px;
                }
                .chat-container {
                    max-width: 675px;
                    margin: auto;
                    background: white;
                    padding: 10px;
                    border-radius: 8px;
                    box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.1);
                }
                h2 {
                    text-align: center;
                    margin-bottom: 20px;
                    color: #333;
                }
                .user-msg {
                    background: #e6e6e6;
                    padding: 6px 10px;
                    border-radius: 5px;
                    margin: 5px 0;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }
                .user-msg.highlighted-yellow {
                    background: yellow;
                }
                .user-msg.highlighted-orange {
                    background: orange;
                }
                .user-msg.subchat {
                    margin-left: 30px;
                    border-left: 2px solid #007bff;
                    padding-left: 6px;
                }
                .timestamp {
                    font-size: 10px;
                    color: #555;
                    margin-left: 8px;
                }
            </style>
        </head>
        <body>
            <div class="chat-container">
                <h2>${chatTitle}</h2>
                ${messages}
            </div>
        </body>
        </html>
    `);
}


    function handleViewChange() {
        const viewSelect = document.getElementById('viewVersion');
        const selectedValue = viewSelect.value;
        
        if (selectedValue === 'v1') {
            openChatInNewWindow();
        } else if (selectedValue === 'v2') {
            openChatInNewWindow2();
        } else if (selectedValue === 'v3') {
            openChatInNewWindow3();
        } else if (selectedValue === 'v4') {
            openChatInNewWindow4();
        } else if (selectedValue === 'v5') {
        	openChatInNewWindow5(); // ‚úÖ This is the new line
    	}
        
        viewSelect.selectedIndex = 0;
    }

    function toggleSubtitleDropdown() {
        const dropdown = document.getElementById("subtitleDropdown");
        
        // Toggle visibility
        if (dropdown.style.display === "block") {
            dropdown.style.display = "none";
        } else {
            dropdown.style.display = "block";
            
            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Get dropdown dimensions after displaying it (to ensure correct offsetWidth/Height)
            const dropdownWidth = dropdown.offsetWidth;
            const dropdownHeight = dropdown.offsetHeight;
            
            // Center horizontally and vertically
            dropdown.style.left = `${(viewportWidth - dropdownWidth) / 2 + window.scrollX}px`;
            dropdown.style.top = `${(viewportHeight - dropdownHeight) / 2 + window.scrollY}px`;
            
            // Remove bottom and transform properties since we're using top/left
            dropdown.style.bottom = "auto";
            dropdown.style.transform = "none";
        }
    }

    function insertCustomSubtitle() {
        const customText = document.getElementById("customSubtitle").value.trim();
        if (customText) {
            insertTextAtCursor(customText);
            document.getElementById("subtitleDropdown").style.display = "none";
        } else {
            alert("Please enter custom subtitle text.");
        }
    }

    function insertSubtitlePreset(text) {
        insertTextAtCursor(text);
        document.getElementById("subtitleDropdown").style.display = "none";
    }

    function addNewPreset() {
        const customText = document.getElementById("customSubtitle").value.trim();
        if (customText) {
            const presetList = document.querySelector(".subtitle-preset-list");
            const newOption = document.createElement("div");
            newOption.className = "subtitle-option";
            newOption.textContent = customText;
            newOption.onclick = function() {
                insertSubtitlePreset(customText);
            };
            presetList.appendChild(newOption);
            document.getElementById("customSubtitle").value = "";
        } else {
            alert("Please enter text to add as a preset.");
        }
    }

    function insertTextAtCursor(text) {
        let textarea = document.getElementById("textInput");
        let currentText = textarea.value;
        let cursorPosition = textarea.selectionStart;
        let textBeforeCursor = currentText.substring(0, cursorPosition);
        let textAfterCursor = currentText.substring(cursorPosition);

        textarea.value = textBeforeCursor + text + textAfterCursor;
        textarea.selectionStart = textarea.selectionEnd = cursorPosition + text.length;
        textarea.focus();
        autoExpand(textarea);
    }

    function handleDragStart(event) {
        const userMsg = event.target.closest(".user-msg");
        if (!userMsg) return;

        // If dragging a message not in the current selection, reset selection
        if (!selectedMessages.has(userMsg) && selectedMessages.size > 0) {
            selectedMessages.forEach(msg => msg.classList.remove("selected"));
            selectedMessages.clear();
        }
        if (selectedMessages.size === 0) {
            selectedMessages.add(userMsg);
            userMsg.classList.add("selected");
        }

        const dragText = Array.from(selectedMessages).map(msg => {
            let textSpan = msg.querySelector(".message-text");
            let timestamp = msg.querySelector(".timestamp");
            let prefix = msg.classList.contains("subchat") ? "  ‚Ä¢" : "‚Ä¢";
            let highlightMarker = msg.classList.contains("highlighted-yellow") || msg.classList.contains("highlighted-orange") ? "[H] " : "";
            let clonedSpan = textSpan.cloneNode(true);
            let checkboxes = clonedSpan.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                let replacement = cb.checked ? '[X]' : '[ ]';
                let span = cb.parentElement;
                span.outerHTML = replacement;
            });
            return `${prefix} ${highlightMarker}${clonedSpan.textContent} (${timestamp.textContent})`;
        }).join("\n");

        event.dataTransfer.setData("text/plain", dragText);
        event.dataTransfer.effectAllowed = "copyMove";

        draggedElement = userMsg;
        selectedMessages.forEach(msg => msg.classList.add("dragging"));
    }

    function handleDragOver(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = draggedElement ? "move" : "copy";
        const target = event.target.closest(".user-msg");
        if (target && target !== draggedElement) {
            target.classList.add("drag-over");
        }
    }

    function handleDrop(event) {
        event.preventDefault();
        event.stopPropagation(); // Prevent event bubbling
        const target = event.target.closest(".user-msg");
        const chatBox = document.getElementById("chatBox");
        const text = event.dataTransfer.getData("text/plain");
        const lines = text.split("\n").filter(line => line.trim() !== "");

        // Internal drag (reordering within the same window)
        if (draggedElement && target && target !== draggedElement) {
            const allMessages = Array.from(chatBox.children);
            const targetIndex = allMessages.indexOf(target);
            const draggedIndex = allMessages.indexOf(draggedElement);

            if (draggedIndex < targetIndex) {
                target.after(draggedElement);
            } else {
                target.before(draggedElement);
            }
            updateSubchatToggles();
            draggedElement.scrollIntoView({ behavior: "smooth", block: "nearest" });
            selectedMessages.clear(); // Clear selection after move
        } 
        // External or cross-window drop
        else if (event.dataTransfer.types.includes("text/plain") && !event.dataTransfer.files.length) {
            const isChatFormat = lines.every(line => 
                line.match(/(  ‚Ä¢|‚Ä¢) (\[H\]\s)?(.*?) \((\d+:\d+ [APM]{2})\)/)
            );
            let addedCount = 0;
            let lastInsertedMessage = target;

            if (isChatFormat && !draggedElement) { // Cross-window chat message drop
                let currentParent = null;
                let subchats = [];

                lines.forEach((line, index) => {
                    const match = line.match(/(  ‚Ä¢|‚Ä¢) (\[H\]\s)?(.*?) \((\d+:\d+ [APM]{2})\)/);
                    if (match) {
                        const isSubchat = match[1] === "  ‚Ä¢";
                        const isHighlighted = !!match[2];
                        let messageText = match[3];
                        const timestamp = match[4];

                        messageText = messageText.replace(/\[X\]/g, '<span class="checkbox-wrapper"><input type="checkbox" checked></span>')
                                                .replace(/\[ \]/g, '<span class="checkbox-wrapper"><input type="checkbox"></span>');

                        const newMessage = sendMessage(messageText, timestamp, true);
                        if (isHighlighted) newMessage.classList.add("highlighted-yellow");

                        if (!isSubchat) {
                            // If there was a previous parent with subchats, finalize it
                            if (currentParent && subchats.length > 0) {
                                const toggleBtn = currentParent.querySelector(".toggle-subchat");
                                toggleBtn.innerHTML = "‚àí";
                                toggleBtn.style.visibility = "visible";
                            }
                            // New parent message
                            currentParent = newMessage;
                            subchats = [];
                            if (lastInsertedMessage) {
                                lastInsertedMessage.after(newMessage);
                            } else {
                                chatBox.appendChild(newMessage);
                            }
                            lastInsertedMessage = newMessage;
                        } else if (currentParent) {
                            // Subchat under the current parent
                            newMessage.classList.add("subchat");
                            subchats.push(newMessage);
                            lastInsertedMessage.after(newMessage);
                            lastInsertedMessage = newMessage;
                        } else {
                            // Orphan subchat (no parent), treat as regular message
                            if (lastInsertedMessage) {
                                lastInsertedMessage.after(newMessage);
                            } else {
                                chatBox.appendChild(newMessage);
                            }
                            lastInsertedMessage = newMessage;
                        }
                        addedCount++;
                    }
                });

                // Finalize the last parent with subchats
                if (currentParent && subchats.length > 0) {
                    const toggleBtn = currentParent.querySelector(".toggle-subchat");
                    toggleBtn.innerHTML = "‚àí";
                    toggleBtn.style.visibility = "visible";
                    // Check if subchats were collapsed in the source
                    const sourceParent = Array.from(selectedMessages).find(msg => !msg.classList.contains("subchat"));
                    if (sourceParent && sourceParent.querySelector(".toggle-subchat")?.innerHTML === "+") {
                        toggleBtn.innerHTML = "+";
                        subchats.forEach(subchat => subchat.classList.add("subchat-hidden"));
                    }
                }

                if (addedCount > 0) {
                    requestAnimationFrame(() => {
                        scrollToBottom(chatBox);
                        updateSubchatToggles();
                        if (lastInsertedMessage) {
                            lastInsertedMessage.scrollIntoView({ behavior: "smooth", block: "nearest" });
                        }
                    });
                    alert(`${addedCount} message(s) dropped from another chat window.`);
                }
            } else if (!isChatFormat && !draggedElement) { // External text drop (e.g., from .txt)
                const newMessage = sendMessage(text.trim(), null, true);
                if (target) {
                    target.after(newMessage);
                } else {
                    chatBox.appendChild(newMessage);
                }
                addedCount = 1;

                requestAnimationFrame(() => {
                    scrollToBottom(chatBox);
                    updateSubchatToggles();
                    newMessage.scrollIntoView({ behavior: "smooth", block: "nearest" });
                });
                alert(`${addedCount} message(s) dropped from external text source.`);
            }
        }

        cleanupDragStyles();
        draggedElement = null; // Reset dragged element
        selectedMessages.forEach(msg => msg.classList.remove("selected"));
        selectedMessages.clear(); // Ensure selection is cleared after drop
    }

    function handleDragEnd(event) {
        cleanupDragStyles();
        draggedElement = null;
        selectedMessages.forEach(msg => msg.classList.remove("selected"));
        selectedMessages.clear(); // Clear selection on drag end
    }

    function cleanupDragStyles() {
        document.querySelectorAll(".user-msg").forEach(msg => {
            msg.classList.remove("dragging", "drag-over");
        });
        document.getElementById("chatBox").style.background = "#fafafa";
        document.querySelector(".chat-container").classList.remove("drag-over");
    }

    function shareChat() {
        let chatTitle = document.getElementById("chatTitle").textContent.trim();
        let messages = Array.from(document.getElementById("chatBox").children).map(div => {
            let textSpan = div.querySelector(".message-text");
            let timestamp = div.querySelector(".timestamp");
            let prefix = div.classList.contains("subchat") ? "  ‚Ä¢" : "‚Ä¢";
            let highlightMarker = div.classList.contains("highlighted-yellow") || div.classList.contains("highlighted-orange") ? "[H] " : "";

            if (!textSpan) return "";

            let clonedSpan = textSpan.cloneNode(true);
            let checkboxes = clonedSpan.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                let replacement = cb.checked ? '[X]' : '[ ]';
                let span = cb.parentElement;
                span.outerHTML = replacement;
            });
            let messageText = clonedSpan.textContent;

            return `${prefix} ${highlightMarker}${messageText} (${timestamp.textContent})`;
        });

        if (messages.length === 0) {
            alert("No chat history to share.");
            return;
        }

        let chatText = chatTitle + "\n\n" + messages.join("\n");

        if (navigator.share) {
            navigator.share({
                title: chatTitle,
                text: chatText,
                url: window.location.href
            })
            .then(() => console.log('Successful share'))
            .catch((error) => console.log('Error sharing:', error));
        } else {
            let shareText = encodeURIComponent(chatText);
            let shareUrl = `mailto:?subject=${encodeURIComponent(chatTitle)}&body=${shareText}`;
            window.open(shareUrl, '_blank');
            
            navigator.clipboard.writeText(chatText)
                .then(() => {
                    alert('Chat copied to clipboard! You can paste it in any app.');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    alert('Please manually copy the chat text and share it in your preferred app.');
                });
        }
    }

    function clearChat() {
        const chatBox = document.getElementById("chatBox");
        if (chatBox.children.length === 0) {
            alert("Chat is already empty!");
            return;
        }
        
        if (confirm("Are you sure you want to clear all chat contents? This action cannot be undone.")) {
            chatBox.innerHTML = "";
            selectedMessages.clear();
            messageClipboard = [];
            alert("Chat cleared successfully.");
        }
    }
    
// Variable to store the file handle, autosave status, and inactivity timeout
let fileHandle = null;
let isAutosaving = false; // Track autosave status
let inactivityTimeout = null; // Track inactivity timeout

// Function to get formatted date (YYYYMMDD Day)
function getFormattedDate() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0'); // Months are 0-based
    const day = String(now.getDate()).padStart(2, '0');
    const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const dayName = weekdays[now.getDay()];
    return `${year}${month}${day} ${dayName}`;
}

// Function to extract base title (removing date if present)
function getBaseTitle(fullTitle) {
    const datePattern = /\d{8} (Sun|Mon|Tue|Wed|Thu|Fri|Sat)$/; // Matches "YYYYMMDD Day"
    return fullTitle.replace(datePattern, '').trim(); // Remove date and trim
}

// Format chat content as text (reusing your existing saveChatAsFile logic)
function getChatContent() {
    let chatTitle = document.getElementById("chatTitle").textContent.trim();
    let messages = Array.from(document.getElementById("chatBox").children).map(div => {
        let textSpan = div.querySelector(".message-text");
        let timestamp = div.querySelector(".timestamp");
        let prefix = div.classList.contains("subchat") ? "  ‚Ä¢" : "‚Ä¢";
        let highlightMarker = div.classList.contains("highlighted-yellow") || div.classList.contains("highlighted-orange") ? "[H] " : "";
        if (!textSpan) return "";
        let clonedSpan = textSpan.cloneNode(true);
        let checkboxes = clonedSpan.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(cb => {
            let replacement = cb.checked ? '[X]' : '[ ]';
            let span = cb.parentElement;
            span.outerHTML = replacement;
        });
        let messageText = clonedSpan.textContent;
        return `${prefix} ${highlightMarker}${messageText} (${timestamp.textContent})`;
    });
    return messages.length > 0 ? chatTitle + "\n\n" + messages.join("\n") : "";
}

// Save to hard drive using File System Access API (shared by autosave and manual save)
async function saveToHardDrive() {
    const chatContent = getChatContent();
    if (!chatContent) {
        console.log("No content to save.");
        return false; // Return false to indicate no save occurred
    }

    const chatTitle = document.getElementById("chatTitle").textContent.trim(); // Get current title
    const baseTitle = getBaseTitle(chatTitle); // Extract title without date
    const fileName = `${baseTitle} ${getFormattedDate()}.txt`; // e.g., "Test system 20250404 Fri.txt"

    if (window.showSaveFilePicker) {
        try {
            // Prompt for file location if not already set
            if (!fileHandle) {
                fileHandle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{
                        description: 'Text Files',
                        accept: { 'text/plain': ['.txt'] },
                    }],
                });
                console.log("File location selected:", await fileHandle.getFile());
            }

            // Write to the selected file
            const writable = await fileHandle.createWritable();
            await writable.write(chatContent);
            await writable.close();
            console.log("Chat saved to hard drive at:", (await fileHandle.getFile()).name);
            return true; // Return true to indicate successful save
        } catch (error) {
            console.error("Error saving to hard drive:", error);
            if (error.name === 'AbortError') {
                console.log("User canceled the save operation.");
                stopAutoSave(); // Stop autosaving if canceled
            } else {
                alert("Failed to save to hard drive. Check console for details.");
                fallbackSaveToDownload(chatContent);
            }
            return false; // Return false on error
        }
    } else {
        console.log("File System Access API not supported. Using download fallback.");
        fallbackSaveToDownload(chatContent);
        return true; // Return true for fallback save
    }
}

// Fallback: Trigger a file download
function fallbackSaveToDownload(chatContent) {
    const chatTitle = document.getElementById("chatTitle").textContent.trim(); // Get current title
    const baseTitle = getBaseTitle(chatTitle); // Extract title without date
    const fileName = `${baseTitle} ${getFormattedDate()}.txt`; // e.g., "Test system 20250404 Fri.txt"
    const blob = new Blob([chatContent], { type: "text/plain" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    console.log("Chat downloaded as a fallback.");
}

// Reset inactivity timeout
function resetInactivityTimeout(autosaveButton) {
    if (inactivityTimeout) {
        clearTimeout(inactivityTimeout); // Clear existing timeout
    }
    if (isAutosaving) {
        inactivityTimeout = setTimeout(() => {
            stopAutoSave(autosaveButton); // Stop autosaving after 1 hour
            console.log("Autosaving turned off due to 1 hour of inactivity.");
        }, 3600000); // 1 hour = 60 minutes * 60 seconds * 1000 ms
    }
}

// Start autosaving (only on typing)
function startAutoSave(autosaveButton) {
    isAutosaving = true; // Enable autosaving
    saveToHardDrive(); // Initial save to set fileHandle if needed
    resetInactivityTimeout(autosaveButton); // Start inactivity timer
    autosaveButton.textContent = "Autosaving...";
    autosaveButton.title = "Click to stop autosaving";
    autosaveButton.onclick = () => stopAutoSave(autosaveButton);
    console.log("Autosaving enabled (saves on new messages).");
}

// Stop autosaving
function stopAutoSave(autosaveButton) {
    if (inactivityTimeout) {
        clearTimeout(inactivityTimeout); // Clear inactivity timeout
        inactivityTimeout = null;
    }
    isAutosaving = false; // Disable autosaving
    autosaveButton.textContent = "üíæ Autosave";
    autosaveButton.title = "Enable autosaving to hard drive";
    autosaveButton.onclick = () => startAutoSave(autosaveButton);
    console.log("Autosaving stopped.");
}

// Add autosave toggle to controls and set initial title
document.addEventListener("DOMContentLoaded", function() {
    // Set initial title with current date
    const chatTitle = document.getElementById("chatTitle");
    chatTitle.textContent = `Title ${getFormattedDate()}`; // e.g., "Title 20250404 Fri"

    const controls = document.querySelector(".controls");
    const autosaveButton = document.createElement("button");
    autosaveButton.textContent = "üíæ Autosave";
    autosaveButton.style.backgroundColor = "#6f42c1"; // Purple
    autosaveButton.style.color = "white";
    autosaveButton.title = "Enable autosaving to hard drive";
    autosaveButton.onclick = () => startAutoSave(autosaveButton);
    controls.insertBefore(autosaveButton, controls.querySelector('button[onclick="saveChatAsFile()"]'));

    // Save on new message only if autosaving is active, and reset inactivity timeout
    const originalSendMessage = window.sendMessage;
    window.sendMessage = function(message, timestamp, isFromFile) {
        const result = originalSendMessage(message, timestamp, isFromFile);
        if (!isFromFile && isAutosaving) {
            saveToHardDrive();
            resetInactivityTimeout(autosaveButton); // Reset timer on new message
        }
        return result;
    };

    // Update saveChatAsFile to reuse the same file like autosave
    const originalSaveChatAsFile = window.saveChatAsFile;
    window.saveChatAsFile = async function() {
        const chatContent = getChatContent();
        if (!chatContent) {
            alert("No chat history to save.");
            return;
        }

        if (await saveToHardDrive()) {
            console.log("Manual save completed using the same file.");
        } else {
            console.log("Manual save failed or was canceled.");
        }
    };
});

// Variables for sync functionality
let syncData = null;
let isSyncing = false;

function syncAcrossDevices() {
    const chatTitle = document.getElementById("chatTitle").textContent.trim();
    const messages = Array.from(document.getElementById("chatBox").children).map(div => {
        const textSpan = div.querySelector(".message-text");
        const timestamp = div.querySelector(".timestamp");
        const isSubchat = div.classList.contains("subchat");
        const isYellow = div.classList.contains("highlighted-yellow");
        const isOrange = div.classList.contains("highlighted-orange");
        
        if (!textSpan) return null;
        
        // Handle checkboxes
        let messageContent = textSpan.innerHTML;
        const checkboxes = textSpan.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(cb => {
            const replacement = cb.checked ? '[X]' : '[ ]';
            const span = cb.parentElement;
            messageContent = messageContent.replace(span.outerHTML, replacement);
        });
        
        return {
            content: messageContent,
            timestamp: timestamp.textContent,
            isSubchat: isSubchat,
            isYellow: isYellow,
            isOrange: isOrange
        };
    }).filter(msg => msg !== null);

    syncData = {
        title: chatTitle,
        messages: messages,
        timestamp: new Date().toISOString()
    };
    
    // Encode data as base64 for URL
    const encodedData = btoa(JSON.stringify(syncData));
    
    // Generate the shareable URL
    const baseUrl = window.location.href.split('?')[0];
    const syncUrl = `${baseUrl}?sync=${encodedData}`;
    
    // Store the URL for copying
    document.getElementById("copyLinkBtn").dataset.syncUrl = syncUrl;
    
    // Show the copy button
    document.getElementById("copyLinkBtn").style.display = "inline-block";
    
    alert("Sync data prepared! Click the 'Copy Link' button to share your chat.");
}

function copySyncLink() {
    const syncUrl = document.getElementById("copyLinkBtn").dataset.syncUrl;
    if (!syncUrl) {
        alert("No sync data available. Please click the Sync button first.");
        return;
    }
    
    navigator.clipboard.writeText(syncUrl)
        .then(() => {
            alert("Sync link copied to clipboard! Send this link to your other device.");
        })
        .catch(err => {
            console.error('Failed to copy: ', err);
            // Fallback for browsers that don't support clipboard API
            prompt("Copy this link:", syncUrl);
        });
}

function loadSyncData() {
    const urlParams = new URLSearchParams(window.location.search);
    const syncParam = urlParams.get('sync');
    
    if (!syncParam) return false;
    
    try {
        const decodedData = atob(syncParam);
        syncData = JSON.parse(decodedData);
        
        if (confirm("Load synced chat? This will replace your current chat.")) {
            // Clear current chat
            document.getElementById("chatBox").innerHTML = "";
            
            // Set title
            document.getElementById("chatTitle").textContent = syncData.title;
            
            // Add messages
            syncData.messages.forEach(msgData => {
                const newMessage = sendMessage(msgData.content, msgData.timestamp, true);
                if (msgData.isSubchat) newMessage.classList.add("subchat");
                if (msgData.isYellow) newMessage.classList.add("highlighted-yellow");
                if (msgData.isOrange) newMessage.classList.add("highlighted-orange");
            });
            
            // Update UI
            updateSubchatToggles();
            scrollToBottom(document.getElementById("chatBox"));
            
            // Clear the URL without reloading
            window.history.replaceState({}, document.title, window.location.pathname);
            
            alert("Chat synced successfully!");
        }
        
        return true;
    } catch (error) {
        console.error("Error loading sync data:", error);
        return false;
    }
}

// Dynalist configuration
let dynalistApiKey = localStorage.getItem('dynalistApiKey') || '';
let dynalistDocId = localStorage.getItem('dynalistDocId') || '';

function showDynalistSettings() {
    document.getElementById('dynalist-token').value = dynalistApiKey;
    document.getElementById('dynalist-doc-id').value = dynalistDocId;
    updateDynalistStatusDisplay();
    document.getElementById('dynalist-modal').style.display = 'block';
}

function closeDynalistModal() {
    document.getElementById('dynalist-modal').style.display = 'none';
}

function updateDynalistStatusDisplay() {
    const statusIcon = document.getElementById('dynalist-status-icon');
    const statusText = document.getElementById('dynalist-status-text');
    
    if (dynalistApiKey) {
        statusIcon.style.backgroundColor = '#06D85F';
        statusText.textContent = dynalistDocId ? 'Configured (Document ID set)' : 'Configured (New doc per day)';
    } else {
        statusIcon.style.backgroundColor = '#ccc';
        statusText.textContent = 'Not configured';
    }
}

async function testDynalistConnection() {
    const token = document.getElementById('dynalist-token').value;
    if (!token) {
        alert('Please enter an API token first');
        return;
    }
    
    try {
        alert('Testing connection...');
        
        const response = await fetch('https://dynalist.io/api/v1/doc/list', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                token: token
            })
        });
        
        const data = await response.json();
        
        if (data._code === 'Ok') {
            alert('Connection successful! You can access ' + data.files.length + ' files.');
        } else {
            alert('Connection failed: ' + (data._msg || 'Unknown error'));
        }
    } catch (error) {
        alert('Connection error: ' + error.message);
    }
}

function saveDynalistSettings() {
    const token = document.getElementById('dynalist-token').value;
    const docId = document.getElementById('dynalist-doc-id').value;
    
    if (!token) {
        alert('API token is required');
        return;
    }
    
    dynalistApiKey = token;
    dynalistDocId = docId;
    
    localStorage.setItem('dynalistApiKey', token);
    localStorage.setItem('dynalistDocId', docId);
    
    updateDynalistStatusDisplay();
    closeDynalistModal();
    alert('Dynalist settings saved!');
}

async function createDynalistDocument() {
    const today = new Date();
    const year = today.getFullYear();
    const month = (today.getMonth() + 1).toString().padStart(2, '0');
    const day = today.getDate().toString().padStart(2, '0');
    const weekday = today.toLocaleDateString('en-US', { weekday: 'short' });
    const time = getCurrentTime();
    const dateString = `${year}${month}${day} (${weekday}) ${time}`;
    
    try {
        const response = await fetch('https://dynalist.io/api/v1/doc/create', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                token: dynalistApiKey,
                title: `Self-Chat ${dateString}`,
                type: 'document'
            })
        });
        
        const data = await response.json();
        
        if (data._code === 'Ok' && data.id) {
            return data.id;
        } else {
            throw new Error(data._msg || 'Failed to create document');
        }
    } catch (error) {
        console.error('Error creating Dynalist document:', error);
        throw error;
    }
}

function formatMessageContent(messageElement) {
    const messageText = messageElement.querySelector('.message-text');
    const timestamp = messageElement.querySelector('.timestamp');
    
    if (!messageText) return '';
    
    let content = messageText.innerHTML;
    
    // Handle checkboxes
    const checkboxes = messageText.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach(cb => {
        const replacement = cb.checked ? '[X]' : '[ ]';
        const span = cb.parentElement;
        content = content.replace(span.outerHTML, replacement);
    });
    
    // Clean up HTML tags
    content = content.replace(/<[^>]*>/g, '').trim();
    
    // Remove the dot prefix that would normally be added
    // Just return the content and timestamp without any bullet point
    return `${content} (${timestamp.textContent})`;
}

async function addContentToDynalist(documentId) {
    try {
        // Create the main header with current date
        const now = new Date();
        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const weekday = now.toLocaleDateString('en-US', { weekday: 'short' });
        const time = getCurrentTime();
        const chatTitle = document.getElementById("chatTitle").textContent.trim();
        const dateHeader = `${chatTitle} - ${year}${month}${day} (${weekday}) ${time}`;
        
        // Create the main session node (header)
        const headerResponse = await fetch('https://dynalist.io/api/v1/doc/edit', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                token: dynalistApiKey,
                file_id: documentId,
                changes: [{
                    action: 'insert',
                    parent_id: 'root',
                    content: dateHeader,
                    index: 0
                }]
            })
        });
        
        const headerData = await headerResponse.json();
        if (headerData._code !== 'Ok') {
            throw new Error('Failed to create header node: ' + (headerData._msg || 'Unknown error'));
        }
        
        const headerNodeId = headerData.new_node_ids ? headerData.new_node_ids[0] : null;
        if (!headerNodeId) {
            throw new Error('Failed to get new header node ID');
        }

        // Add conversation messages
        const messageElements = Array.from(document.querySelectorAll('.user-msg')).filter(msg => msg.querySelector('.message-text'));
        
        for (let i = 0; i < messageElements.length; i++) {
            const msg = messageElements[i];
            const messageContent = formatMessageContent(msg);

            try {
                const response = await fetch('https://dynalist.io/api/v1/doc/edit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        token: dynalistApiKey,
                        file_id: documentId,
                        changes: [{
                            action: 'insert',
                            parent_id: headerNodeId,
                            content: messageContent,
                            index: i
                        }]
                    })
                });
                
                const data = await response.json();
                if (data._code !== 'Ok') {
                    console.warn('Failed to add message node:', data._msg);
                    continue;
                }
                
                // Add delay between requests to avoid rate limiting
                if (i < messageElements.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
            } catch (error) {
                console.warn('Error adding message node:', error);
                continue;
            }
        }
        
        return { documentId, headerNodeId };
    } catch (error) {
        console.error('Error in addContentToDynalist:', error);
        throw error;
    }
}

async function sendToDynalist() {
    if (!dynalistApiKey) {
        alert('Please configure Dynalist settings first');
        showDynalistSettings();
        return;
    }
    
    // Check if there are messages to export
    const messageElements = Array.from(document.querySelectorAll('.user-msg')).filter(msg => msg.querySelector('.message-text'));
    if (messageElements.length === 0) {
        alert('No conversation content to export. Please add some messages first.');
        return;
    }
    
    try {
        alert('Exporting to Dynalist...');
        
        // Get or create document ID
        let documentId = dynalistDocId;
        let createdNewDoc = false;
        
        if (!documentId) {
            documentId = await createDynalistDocument();
            if (!documentId) {
                throw new Error('Failed to create document');
            }
            // Save the new document ID
            dynalistDocId = documentId;
            localStorage.setItem('dynalistDocId', documentId);
            createdNewDoc = true;
        }
        
        // Add content to Dynalist
        const result = await addContentToDynalist(documentId);
        
        if (createdNewDoc) {
            alert('Successfully exported to new Dynalist document! Opening...');
        } else {
            alert('Successfully exported to existing Dynalist document! Opening...');
        }
        
        // Open Dynalist in popup window
        setTimeout(() => {
            const dynalistUrl = `https://dynalist.io/d/${documentId}`;
            const popupWindow = window.open(
                dynalistUrl,
                'DynalistPopup',
                'width=1000,height=700,resizable=yes,scrollbars=yes,top=100,left=100,toolbar=no,menubar=no,location=no'
            );
            
            if (!popupWindow || popupWindow.closed || typeof popupWindow.closed == 'undefined') {
                // Popup blocked, fallback to new tab
                alert('Popup blocked! Opening in new tab instead.');
                window.open(dynalistUrl, '_blank');
            }
        }, 2000);
        
    } catch (error) {
        console.error('Dynalist export error:', error);
        alert('Error exporting to Dynalist: ' + error.message);
        
        // If there was an error with the document, clear the stored ID
        if (error.message.includes('document') || error.message.includes('permission')) {
            dynalistDocId = '';
            localStorage.removeItem('dynalistDocId');
            alert('Cleared invalid document ID. Please try again with a new document.');
        }
    }
}

// Add event listeners for Dynalist modal
document.addEventListener('DOMContentLoaded', function() {
    const dynalistModal = document.getElementById('dynalist-modal');
    if (dynalistModal) {
        document.querySelector('.close-modal').addEventListener('click', closeDynalistModal);
        document.getElementById('test-connection').addEventListener('click', testDynalistConnection);
        document.getElementById('save-dynalist').addEventListener('click', saveDynalistSettings);
        
        // Close modal when clicking outside
        window.addEventListener('click', (e) => {
            if (e.target === dynalistModal) {
                closeDynalistModal();
            }
        });
    }
    
    // Initialize Dynalist status
    updateDynalistStatusDisplay();
});


// Call this function when the page loads
document.addEventListener("DOMContentLoaded", function() {
    // Check for sync data in URL
    setTimeout(() => {
        loadSyncData();
    }, 500);
});

</script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'91f03c4a183a7bae',t:'MTc0MTc1MDQ2My4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>

<!-- Dynalist Modal -->
<div class="modal" id="dynalist-modal" style="display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);">
    <div class="modal-content" style="background-color: white; margin: 10% auto; padding: 25px; border-radius: 12px; width: 90%; max-width: 500px; box-shadow: 0 5px 20px rgba(0,0,0,0.2);">
        <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 class="modal-title" style="font-size: 1.3rem; color: #6e8efb; font-weight: 600;">Dynalist Settings</h3>
            <button class="close-modal" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;">&times;</button>
        </div>
        <div class="modal-body" style="margin-bottom: 20px;">
            <div class="form-group" style="margin-bottom: 15px;">
                <label class="form-label" for="dynalist-token" style="display: block; margin-bottom: 5px; font-weight: 500; color: #555;">API Token</label>
                <input type="password" id="dynalist-token" class="form-input" placeholder="Enter your Dynalist API token" style="width: 100%; padding: 10px; border: 2px solid #e0e6ff; border-radius: 8px; font-size: 0.95rem; transition: border-color 0.3s;">
                <div class="form-help" style="font-size: 0.8rem; color: #666; margin-top: 5px;">
                    Get your API token from: <a href="https://dynalist.io/developer" target="_blank">https://dynalist.io/developer</a>
                </div>
            </div>
            <div class="form-group" style="margin-bottom: 15px;">
                <label class="form-label" for="dynalist-doc-id" style="display: block; margin-bottom: 5px; font-weight: 500; color: #555;">Document ID (Optional)</label>
                <input type="text" id="dynalist-doc-id" class="form-input" placeholder="Leave empty to create new document each day" style="width: 100%; padding: 10px; border: 2px solid #e0e6ff; border-radius: 8px; font-size: 0.95rem; transition: border-color 0.3s;">
                <div class="form-help" style="font-size: 0.8rem; color: #666; margin-top: 5px;">
                    If specified, all exports will go to this document. Leave empty to create a new document for each day.
                </div>
            </div>
            <div class="form-group" style="margin-bottom: 15px;">
                <label class="form-label" style="display: block; margin-bottom: 5px; font-weight: 500; color: #555;">Current Status</label>
                <div id="dynalist-status-display">
                    <span class="dynalist-status dynalist-disabled" id="dynalist-status-icon" style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; background-color: #ccc;"></span>
                    <span id="dynalist-status-text">Not configured</span>
                </div>
            </div>
        </div>
        <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 10px;">
            <button class="btn btn-secondary" id="test-connection" style="padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; transition: all 0.3s; background: #f0f4ff; color: #6e8efb;">Test Connection</button>
            <button class="btn btn-primary" id="save-dynalist" style="padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; transition: all 0.3s; background: #6e8efb; color: white;">Save Settings</button>
        </div>
    </div>
</div>

</body>
</html>