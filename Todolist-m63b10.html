<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart To-Do List</title>
<style>
    :root {
        --primary-color: #4361ee;
        --secondary-color: #3f37c9;
        --accent-color: #4895ef;
        --light-color: #f8f9fa;
        --dark-color: #212529;
        --success-color: #4cc9f0;
        --danger-color: #f72585;
        --section-color: #7209b7;
        --border-color: #adb5bd;
        --shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    * {
        -webkit-tap-highlight-color: transparent;
        box-sizing: border-box;
    }
    
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        line-height: 1.4;
        color: var(--dark-color);
        background-color: #f5f7fa;
        margin: 0 auto;
        padding: 1rem;
        min-height: 100vh;
        touch-action: manipulation;
        max-width: 800px;
        position: relative;
    }
    
    .container {
        background-color: white;
        padding: 1.5rem;
        border-radius: 8px;
        box-shadow: var(--shadow);
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        min-height: calc(100vh - 2rem);
    }
    
    h1 {
        color: var(--primary-color);
        text-align: center;
        margin-bottom: 1.5rem;
        font-size: 1.5rem;
        font-weight: 600;
    }
    
.input-group {
    display: flex;
    margin-bottom: 1rem;
    gap: 0.5rem;
    flex-wrap: wrap;
    align-items: stretch; /* Ensures equal height */
}

#title {
    width: 100%;
    font-size: 1rem;
    padding: 0.8rem;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 1rem;
    transition: border-color 0.2s;
    background-color: white;
}

#new-item {
    flex: 1 1 300px; /* Reduced from 500px for better mobile behavior */
    padding: 0.8rem;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    font-size: 1rem;
    min-width: 0;
    min-height: 50px;
    box-sizing: border-box; /* Ensures padding doesn't affect width */
}

/* Add button styling */
.input-group > button[onclick="addItem()"] {
    flex: 0 0 auto; /* Prevent flex growing/shrinking */
    width: 100px; /* Fixed width */
    min-width: 100px; /* Prevents shrinking below this */
    min-height: 50px; /* Matches input height */
    padding: 0;
    border-radius: 8px;
    font-size: 0.95rem;
    white-space: nowrap;
}

/* Mobile responsiveness */
@media (max-width: 700px) {
    #new-item {
        flex: 1 1 200px; /* More flexible on smaller screens */
    }
    
    .input-group > button[onclick="addItem()"] {
        width: 80px;
        min-width: 80px;
        font-size: 0.9rem;
    }
}

@media (max-width: 500px) {
    #new-item {
        flex: 1 1 100%; /* Full width on very small screens */
        min-height: 45px; /* Slightly reduced height */
    }
    
    .input-group > button[onclick="addItem()"] {
        width: 100%;
        min-width: 100%;
        margin-top: 0.3rem; /* Space between input and button when stacked */
    }
    
    /* Stack vertically on very small screens */
    .input-group {
        flex-direction: column;
        gap: 0.3rem;
    }
}
    
    button {

        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 0.5rem 0.3rem; 
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s;
        font-size: 0.95rem;
        border-radius: 8px;
        min-width: fit-content;
        white-space: nowrap;
        flex: 1 1 auto;
    }
    
    button:hover {
        background-color: var(--secondary-color);
    }
    
    button.secondary {
        background-color: var(--light-color);
        color: var(--dark-color);
        border: 1px solid var(--border-color);
    }
    
    button.secondary:hover {
        background-color: #e9ecef;
    }
    
    button.danger {
        background-color: var(--danger-color);
    }
    
    button.danger:hover {
        background-color: #d1145a;
    }
    
    button.section-btn {
        background-color: var(--section-color);
    }
    
    button.section-btn:hover {
        background-color: #5a189a;
    }
    
    .controls {
        display: flex;
        gap: 0.3rem;
        margin: 1.0rem 0;
        flex-wrap: wrap;
    }
    
    .controls button {
        flex: 1 1 calc(25% - 0.5rem);
        min-width: 120px;
        max-width: 120px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.2rem;
    }
    
    #todo-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    
    .todo-item {
        display: flex;
        align-items: center;
        padding: 0.1rem;
        margin-bottom: 0.1rem;
        background-color: white;
        border-radius: 8px;
        box-shadow: var(--shadow);
        transition: all 0.2s;
        cursor: pointer;
        position: relative;
    }
    
    .todo-item.section-break {
        background-color: rgba(114, 9, 183, 0.1);
        border-left: 1px solid var(--section-color);
        padding: 0.0rem 0.3rem;
        margin: 0.1rem 0;
    }
    
    .todo-item.section-break .item-text {
        font-weight: bold;
        color: var(--section-color);
    }
    
    .todo-item:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    }
    
    .todo-item.dragging {
        opacity: 0.6;
        background-color: var(--light-color);
    }
    
    .todo-item.completed {
        background-color: #f8f9fa;
    }
    
    .todo-item.completed .item-text {
        text-decoration: line-through;
        color: #6c757d;
    }
    
    .drag-handle {
        cursor: move;
        margin-right: 0.8rem;
        color: var(--border-color);
        font-size: 1.1rem;
        transition: color 0.2s;
        padding: 0.2rem;
        flex-shrink: 0;
    }
    
    .todo-item:hover .drag-handle {
        color: var(--primary-color);
    }
    
    .todo-item.section-break:hover .drag-handle {
        color: var(--section-color);
    }
    
    /* Update the checkbox styles (replace existing .item-checkbox styles) */
    .item-checkbox {
        margin-right: 0.8rem;
        width: 1.3rem;
        height: 1.3rem;
        cursor: pointer;
        flex-shrink: 0;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background-color: white;
        border: 2px solid var(--border-color);
        border-radius: 4px;
        position: relative;
        transition: all 0.2s;
    }

    .item-checkbox:checked {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E");
        background-position: center;
        background-repeat: no-repeat;
        background-size: 80%;
    }

    /* Better contrast on hover */
    .item-checkbox:hover {
        border-color: var(--secondary-color);
    }

@media screen and (-webkit-min-device-pixel-ratio:0) {
    .item-checkbox {
        -webkit-appearance: none;
        appearance: none;
        background-color: white;
    }
}

/* Better contrast on hover */
.item-checkbox:hover {
    border-color: var(--secondary-color);
}

    
    .item-text {
        flex: 1;
        margin-right: 0.8rem;
        padding: 0.2rem 0;
        cursor: text;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 1rem;
    }
    
.item-edit {
    width: 100%;
    min-height: 3rem;
    resize: vertical;
    font-size: 1rem;
    padding: 0.6rem;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    background-color: white;
    display: none;
    box-sizing: border-box;
}
    
    .delete-btn {
        background: none;
        border: none;
        color: var(--danger-color);
        cursor: pointer;
        font-size: 1.5rem;
        opacity: 0.7;
        transition: opacity 0.2s;
        padding: 0.2rem;
        flex-shrink: 0;
        min-width: 30px;
        max-width: 40px;
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .delete-btn:hover {
        opacity: 1;
    }
    
    .saved-lists {
        margin-top: 1.5rem;
        padding-top: 1.5rem;
        border-top: 1px solid var(--border-color);
    }
    
    .saved-lists h2 {
        color: var(--primary-color);
        margin-bottom: 0.8rem;
        font-size: 1.1rem;
    }
    
    .saved-files-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 0.5rem;
    }
    
    .saved-file {
        padding: 0.8rem;
        background-color: white;
        border-radius: 8px;
        box-shadow: var(--shadow);
        transition: all 0.2s;
        cursor: pointer;
        position: relative;
        min-height: 80px;
    }
    
    .saved-file:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    
    .saved-file-name {
        font-weight: 500;
        margin-bottom: 0.3rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        padding-right: 1.5rem;
    }
    
    .saved-file-date {
        font-size: 0.75rem;
        color: #6c757d;
    }
    
    .delete-saved-btn {
        position: absolute;
        top: 0.3rem;
        right: 0.3rem;
        background: none;
        border: none;
        color: var(--danger-color);
        cursor: pointer;
        font-size: 1rem;
        opacity: 0.7;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .delete-saved-btn:hover {
        opacity: 1;
    }
    
/* Updated status styles */
#status {
    position: fixed;
    top: 20px;
    right: 20px;
    max-width: 300px;
    padding: 12px 16px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.15);
    z-index: 100;
    display: none;
    opacity: 1;
    transition: opacity 0.3s ease;
    font-size: 0.9rem;
    animation: slideIn 0.3s ease forwards;
}

@keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}

#status.fade-out {
    opacity: 0;
}

/* Adjust position on small screens */
@media (max-width: 700px) {
    #status {
        top: 10px;
        right: 10px;
        left: 10px;
        max-width: calc(100% - 20px);
        animation: slideInMobile 0.3s ease forwards;
    }
    
    @keyframes slideInMobile {
        from { transform: translateY(-100%); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
    }
}
    
    .empty-state {
        text-align: center;
        padding: 1.5rem;
        color: #6c757d;
        font-size: 0.9rem;
    }
    
    #current-folder {
        font-size: 0.8rem;
        color: #6c757d;
        margin-top: 0.5rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        padding: 0.5rem;
        background-color: #f8f9fa;
        border-radius: 8px;
    }
    
    .footer {
        text-align: center;
        font-size: 0.8rem;
        color: #6c757d;
        padding: 1rem 0;
        margin-top: 1.5rem;
    }
    
    .modal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 1.5rem;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        z-index: 1000;
        width: 90%;
        max-width: 400px;
        max-height: 80vh;
        overflow-y: auto;
    }
    
    .modal h3 {
        margin-top: 0;
        color: var(--primary-color);
        font-size: 1.3rem;
    }
    
    .modal-content {
        margin: 1rem 0;
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
    }
    
    .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
        margin-top: 1rem;
    }
    
    .modal-actions button {
        min-width: 80px;
    }
    
    .overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        z-index: 999;
    }
    
    #import-content, #export-content {
        width: 100%;
        height: 150px;
        margin: 1rem 0;
        padding: 0.8rem;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-family: inherit;
        font-size: 0.9rem;
    }
    
    .import-format label, .export-format label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
        margin-bottom: 0.5rem;
        font-size: 0.95rem;
        padding: 0.3rem 0;
    }
    
    input[type="radio"] {
        width: 1.1rem;
        height: 1.1rem;
    }
    

    
    @media (max-width: 500px) {
        .container {
            padding: 1rem;
        }
        
.controls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem;
    margin: 1rem 0;
}

/* Base button style - 3 per row */
.controls button {
    flex: 1 1 calc(33.333% - 0.4rem);
    min-width: calc(33.333% - 0.4rem);
    max-width: calc(33.333% - 0.4rem);
    padding: 0.6rem 0.3rem; /* More compact padding */
    font-size: 0.85rem; /* Slightly smaller text */
}

/* Tablets - 3 buttons per row */
@media (max-width: 700px) {
    .controls button {
    flex: 1 1 calc(33.333% - 0.4rem);
    min-width: calc(33.333% - 0.4rem);
    max-width: calc(33.333% - 0.4rem);
    padding: 0.6rem 0.3rem; /* More compact padding */
    font-size: 0.85rem; /* Slightly smaller text */
    }
}

/* Small phones - 3 buttons per row (more space) */
@media (max-width: 400px) {
    .controls button {
    flex: 1 1 calc(33.333% - 0.4rem);
    min-width: calc(33.333% - 0.4rem);
    max-width: calc(33.333% - 0.4rem);
    padding: 0.6rem 0.3rem; /* More compact padding */
    font-size: 0.85rem; /* Slightly smaller text */
    }
}       

 
/* Mobile-specific Add button styling */
@media (max-width: 600px) {
    .input-group > button[onclick="addItem()"] {
        height: 50px; /* More reasonable mobile height */
        line-height: 50px; /* Matches height for vertical center */
        width: 70px; /* Slightly wider for better touch */
        min-width: 70px;
        flex: 0 0 auto;
        padding: 0;
        margin-left: 0.3rem; /* Spacing from input */
        font-size: 0.9rem; /* Adjust font size */
    }
    
    /* Make input field fill remaining space */
    #new-item {
        flex: 1 1 auto;
        min-width: 0;
    }
}

/* For very small phones */
@media (max-width: 400px) {
    .input-group > button[onclick="addItem()"] {
        width: 60px;
        min-width: 60px;
        font-size: 0.8rem;
    }
}
        
        .saved-files-container {
            grid-template-columns: 1fr;
        }
        
        .modal {
            width: 95%;
            padding: 1rem;
        }
        
        .modal-actions {
            flex-direction: column;
        }
        
        .modal-actions button {
            width: 100%;
        }
        
        h1 {
            font-size: 1.3rem;
        }
    }

@media print {
    .print-checkbox {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 1px solid #000;
        margin-right: 10px;
        text-align: center;
        line-height: 18px;
        font-size: 16px;
        vertical-align: middle;
    }
    
    .print-item {
        display: flex;
        align-items: center;
        margin: 8px 0;
        page-break-inside: avoid;
    }
    
    .print-item-text {
        flex: 1;
    }
    
    .print-title {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 15px;
        color: #000;
    }
    
    .print-date {
        font-size: 14px;
        color: #666;
        margin-bottom: 20px;
    }
    
    .print-section {
        font-weight: bold;
        font-size: 18px;
        margin: 15px 0 8px 0;
        padding-bottom: 3px;
        border-bottom: 1px solid #ddd;
    }
}

/* Share modal specific styles */
.share-options {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.share-option {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    background-color: white;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    min-height: 80px;
    border: none;
    background-color: var(--light-color);
}

.share-option:hover {
    background-color: #e9ecef;
    transform: translateY(-1px);
    box-shadow: var(--shadow);
}

.share-option span {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
}

#share-text {
    width: 100%;
    height: 150px;
    margin: 1rem 0;
    padding: 0.8rem;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    font-family: inherit;
    font-size: 0.9rem;
    resize: none;
}

/* Email-specific formatting */
.email-html {
    font-family: Arial, sans-serif;
    line-height: 1.5;
    color: #333;
}

.email-html h2 {
    color: #4361ee;
    border-bottom: 2px solid #4361ee;
    padding-bottom: 5px;
}

.email-html h3 {
    color: #7209b7;
    margin-top: 15px;
    border-bottom: 1px solid #ddd;
    padding-bottom: 3px;
}

.email-html ul {
    padding-left: 20px;
    list-style-type: none;
}

.email-html li {
    margin-bottom: 8px;
    position: relative;
    padding-left: 25px;
}

.email-html li:before {
    content: "‚Ä¢";
    position: absolute;
    left: 0;
    color: #4361ee;
}

.empty-state {
    text-align: center;
    padding: 1.5rem;
    color: #6c757d;
    font-size: 0.9rem;
    background-color: #f8f9fa;
    border-radius: 8px;
    margin: 1rem 0;
}

.import-options {
    margin-bottom: 1rem;
}

.import-options label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    font-size: 0.95rem;
    padding: 0.3rem 0;
}

/* Help button specific style */
button.help-btn {
    background-color: #6c757d;
}

button.help-btn:hover {
    background-color: #5a6268;
}

/* Help modal content */
.help-section {
    margin-bottom: 1.5rem;
}

.help-section h4 {
    color: var(--primary-color);
    margin-bottom: 0.5rem;
}

.help-section ul {
    padding-left: 1.5rem;
    margin: 0.5rem 0;
}

.help-section li {
    margin-bottom: 0.5rem;
    line-height: 1.5;
}

    /* Hide desktop buttons on mobile */
    @media (max-width: 500px) {
        .desktop-only {
            display: none !important;
        }
    }
    
    /* Hide mobile buttons on desktop */
    @media (min-width: 600px) {
        .mobile-only {
            display: none !important;
        }
    }

/* Template button style */
button.template-btn {
    background-color: #6c757d;
}
button.template-btn:hover {
    background-color: #5a6268;
}

/* Template options grid */
.template-options {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 0.8rem;
    margin-bottom: 1.5rem;
}

.template-option {
    padding: 1rem;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
}
.template-option:hover {
    background-color: var(--light-color);
    transform: translateY(-2px);
}

.template-option h4 {
    color: var(--primary-color);
    margin: 0 0 0.5rem 0;
}

.template-option p {
    font-size: 0.8rem;
    color: var(--border-color);
    margin: 0;
}

/* File upload */
.file-upload {
    margin: 1.5rem 0;
}
.file-upload label {
    display: block;
    margin-bottom: 0.5rem;
}

    /*  üëá Add drag-and-drop loading support */
#drop-button.dragover {
    background-color: #dbeafe !important;
    border: 2px dashed #4361ee;
}

.note-btn {
    background: none;
    border: none;
    color: var(--accent-color);
    cursor: pointer;
    font-size: 1.2rem;
    opacity: 0.7;
    transition: opacity 0.2s;
    padding: 0.2rem;
    flex-shrink: 0;
    min-width: 30px;
    max-width: 40px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 0.3rem;
}

.note-btn:hover {
    opacity: 1;
}

.todo-item.section-break .note-btn {
    display: none;
}

/* Floating arrow buttons */
/* Remove the existing scroll button styles and replace with these */
/* Floating arrow buttons - Transparent version */
/* Floating arrow buttons - Outside container edge */
#scroll-up-btn, #scroll-down-btn {
    position: fixed;
    left: -18px; /* Half of button width (36px) to align edge */
    width: 36px;
    height: 36px;
    font-size: 1.2rem;
    border-radius: 50%;
    border: none;
    background-color: rgba(114, 9, 183, 0.2);
    color: white;
    cursor: pointer;
    z-index: 10;
    opacity: 0.6;
    box-shadow: none;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    transform: translateX(0);
    transition: transform 0.2s ease, opacity 0.2s ease;
}

/* Button hover states */
#scroll-up-btn:hover,
#scroll-down-btn:hover {
    background-color: rgba(114, 9, 183, 0.5);
    opacity: 1;
    transform: translateX(8px); /* Slide slightly right on hover */
}

/* Individual button positions */
#scroll-up-btn {
    bottom: 2.5rem;
    display: none;
}

#scroll-down-btn {
    top: 6rem;
    display: none;
}

/* Adjust for container on larger screens */
@media (min-width: 800px) {
    #scroll-up-btn, #scroll-down-btn {
        left: calc(50% - 400px - 18px); /* Container width is 800px, so 50% - 400px centers */
    }
}

/* Hide on mobile */
@media (max-width: 700px) {
    #scroll-up-btn, #scroll-down-btn {
        display: none !important;
    }
}

/* Make sure the todo-wrapper has relative positioning */
.todo-wrapper {
    position: relative;
}

/* Hide buttons on small screens */
@media (max-width: 700px) {
    #scroll-up-btn, #scroll-down-btn {
        display: none !important;
    }
}


.note-preview {
    position: absolute;
    bottom: 100%;
    left: 0;
    margin-top: -0.5rem;
    background-color: white;
    border: 1px solid var(--border-color);
    padding: 0.5rem;
    border-radius: 8px;
    box-shadow: var(--shadow);
    font-size: 0.85rem;
    color: var(--dark-color);
    white-space: pre-wrap;
    max-width: 300px;
    z-index: 999;
    display: none;
}

.todo-item:hover .note-btn.has-note + .note-preview {
    display: block;
}

.todo-item .note-btn.has-note {
    font-weight: bold;
    color: var(--accent-color);
}

/* Note indicator dot */
.note-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    background-color: var(--accent-color);
    border-radius: 50%;
    margin-right: 8px;
    vertical-align: middle;
    opacity: 0;
    transition: opacity 0.2s;
    position: relative; /* Add this for positioning the tooltip */
    cursor: pointer; /* Show pointer cursor on hover */

}

.todo-item:hover .note-indicator {
    opacity: 1;
}

.todo-item .note-btn.has-note ~ .note-indicator {
    opacity: 1;
}

/* Add tooltip style for the note indicator */
.note-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    background-color: var(--accent-color);
    border-radius: 50%;
    margin-right: 8px;
    margin-left: 0.5rem;
    vertical-align: middle;
    opacity: 0;
    transition: opacity 0.2s;
    position: relative;
    cursor: pointer;
}

.todo-item:hover .note-indicator {
    opacity: 1;
}

.todo-item .note-btn.has-note ~ .note-indicator {
    opacity: 1;
}

.note-indicator:hover::after {
    content: attr(data-note);
    position: absolute;
    bottom: 100%;
    left: 0;
    background-color: white;
    color: var(--dark-color);
    padding: 0.8rem;
    border-radius: 8px;
    box-shadow: var(--shadow);
    white-space: pre-wrap;
    min-width: 250px;
    max-width: 400px;
    width: max-content;
    max-height: 300px;
    overflow-y: auto;
    z-index: 999;
    display: block;
    font-size: 0.85rem;
    border: 1px solid var(--border-color);
    pointer-events: none;
}

.todo-item.section-break .note-indicator {
    display: none;
}

/* Add to your CSS */
.todo-item[data-indent="1"] { margin-left: 1.5rem; }
.todo-item[data-indent="2"] { margin-left: 3rem; }
.todo-item[data-indent="3"] { margin-left: 4.5rem; }
.todo-item[data-indent="4"] { margin-left: 6rem; }
.todo-item[data-indent="5"] { margin-left: 7.5rem; }

/* Style the indent/outdent buttons */
.indent-btn,
.outdent-btn {
    font-size: 0.9rem;
    padding: 0.2rem 0.3rem;
    min-width: 24px;
    max-width: 30px;
    height: 32px;
    border: none;
    background: none;
    color: #888;
    cursor: pointer;
    opacity: 0.6;
}

.indent-btn:hover,
.outdent-btn:hover {
    opacity: 1;
    color: #333;
}

/* For regular todo items */
.todo-item:not(.section-break):not(:hover) .delete-btn,
.todo-item:not(.section-break):not(:hover) .note-btn,
.todo-item:not(.section-break):not(:hover) .indent-btn,
.todo-item:not(.section-break):not(:hover) .outdent-btn {
    display: none;
}

.todo-item:not(.section-break):not(:hover) .item-text {
    margin-right: 0;
    padding-right: 0;
    max-width: 100%;
}

/* For section items - only hide note/indent/outdent buttons */
.todo-item.section-break:not(:hover) .note-btn,
.todo-item.section-break:not(:hover) .indent-btn,
.todo-item.section-break:not(:hover) .outdent-btn {
    display: none;
}

.todo-item.section-break:not(:hover) .item-text {
    margin-right: 0;
    padding-right: 0;
    max-width: 100%;
}

/* Always show delete button for sections (but still hide on non-hover) */
.todo-item.section-break .delete-btn {
    display: block;
    opacity: 0.3; /* Make it less prominent when not hovered */
    transition: opacity 0.2s ease;
}

.todo-item.section-break:hover .delete-btn {
    opacity: 1;
}

/* Restore normal layout on hover for all items */
.todo-item:hover .item-text {
    margin-right: 0.8rem;
    max-width: calc(100% - 120px);
}

/* Mobile adaptation */
@media (hover: none) {
    .todo-item .delete-btn,
    .todo-item .note-btn,
    .todo-item .indent-btn,
    .todo-item .outdent-btn {
        display: block;
        opacity: 0.7;
    }
    .todo-item .item-text {
        margin-right: 0.8rem;
        max-width: calc(100% - 120px);
    }
    .todo-item.section-break .delete-btn {
        opacity: 0.7;
    }
}

/* For Section items - completely hide delete button when not hovered */
.todo-item.section-break .delete-btn {
    display: none;
    opacity: 0;
    width: 0;
    padding: 0;
    margin: 0;
}

/* Show delete button only when hovering Section item */
.todo-item.section-break:hover .delete-btn {
    display: block;
    opacity: 1;
    width: auto;
    padding: 0.2rem;
    margin-left: 0.3rem;
}

/* Ensure text expands fully when delete button is hidden */
.todo-item.section-break:not(:hover) .item-text {
    margin-right: 0;
    padding-right: 0;
    max-width: 100%;
}

/* Filename tooltip styles */
.saved-file-name {
    position: relative;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.saved-file-name:hover::after {
    content: attr(data-filename);
    position: absolute;
    left: 0;
    top: 100%;
    background: var(--dark-color);
    color: white;
    padding: 0.5rem;
    border-radius: 4px;
    white-space: normal;
    z-index: 100;
    font-size: 0.8rem;
    min-width: max-content;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    display: block !important; /* Force display */
    opacity: 1 !important; /* Force visibility */
}

/* Mobile touch adaptation */
@media (hover: none) {
    .saved-file-name::after {
        content: none !important;
    }
    .saved-file-name {
        white-space: normal;
        overflow: visible;
    }
}

/* Add to your CSS section */
#note-modal button {
    background-color: var(--light-color);
    color: var(--dark-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 0.3rem 0.6rem;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s;
}

#note-modal button:hover {
    background-color: #e9ecef;
}

/* Style for the bullet button in modal actions */
.modal-actions .bullet-btn {
    width: 36px;
    min-width: 36px;
    padding: 0;
    margin: 0 0.25rem;
    font-size: 1.2rem;
    line-height: 1;
    background-color: var(--light-color);
    color: var(--dark-color);
    border: 1px solid var(--border-color);
}

.modal-actions .bullet-btn:hover {
    background-color: #e9ecef;
    transform: scale(1.1);
}

/* Formatting buttons */
.modal-actions .bullet-btn,
.modal-actions .numbered-btn {
    width: 2.5rem;
    min-width: 2.5rem;
    padding: 0.5rem 0;
    font-size: 1.1rem;
    background-color: var(--light-color);
    border: 1px solid var(--border-color);
    border-radius: 8px;
}

.modal-actions .bullet-btn:hover,
.modal-actions .numbered-btn:hover {
    background-color: #e9ecef;
    transform: scale(1.05);
}

.modal-actions .numbered-btn {
    font-size: 0.9rem;
    padding: 0.5rem 0.2rem;
}

@media (max-width: 500px) {
    .controls button {
        /* Adjust other button styles as needed */
    }
    
    /* Make sure the new button fits well on mobile */
    button[onclick="addSectionToTop()"] {
        font-size: 0.85rem;
        padding: 0.6rem 0.3rem;
    }
}

.toggle-btn {
    background: none;
    border: none;
    font-size: 1rem;
    width: 1.2rem;             /* Desired narrow width */
    height: 1.2rem;
    padding: 0;
    margin-right: 0.3rem;
    line-height: 1.2rem;
    text-align: center;
    cursor: pointer;
    color: var(--section-color);
    opacity: 0.8;
    flex: 0 0 auto;            /* üëà KEY: Prevents expanding */
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

/* Add to your CSS section */
button[onclick="toggleAllSections()"] {
    background-color: var(--section-color);
    color: white;
}

button[onclick="toggleAllSections()"]:hover {
    background-color: #5a189a;
}

/* Green button style */
button.green-btn {
    background-color: #28a745; /* Bootstrap-like green */
    color: white;
}

button.green-btn:hover {
    background-color: #218838; /* Darker green on hover */
}

button.green-btn {
    background-color: #28a745;
    color: white;
    font-weight: bold;
    border: 1px solid #218838;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

button.green-btn:hover {
    background-color: #218838;
    transform: translateY(-1px);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

button.green-btn:active {
    transform: translateY(0);
    box-shadow: none;
}

button[onclick="toggleCleanView()"] {
    background-color: #6a5acd;
}
button[onclick="toggleCleanView()"]:hover {
    background-color: #5a4cbd;
}

/* Style both add buttons the same way */
.input-group > button[onclick="addItem()"],
.input-group > button[onclick="addItemToTop()"] {
    flex: 0 0 auto; /* Prevent flex growing/shrinking */
    width: 100px; /* Fixed width */
    min-width: 100px; /* Prevents shrinking below this */
    min-height: 50px; /* Matches input height */
    padding: 0;
    border-radius: 8px;
    font-size: 0.95rem;
    white-space: nowrap;
}

/* Mobile responsiveness */
@media (max-width: 700px) {
    .input-group > button[onclick="addItemToTop()"] {
        width: 80px;
        min-width: 80px;
        font-size: 0.9rem;
    }
}

@media (max-width: 500px) {
    .input-group > button[onclick="addItemToTop()"] {
        width: 100%;
        min-width: 100%;
        margin-top: 0.3rem; /* Space between input and button when stacked */
    }
}

button#auto-save-btn {
    background-color: var(--light-color);
    color: var(--dark-color);
    border: 1px solid var(--border-color);
}

button#auto-save-btn.active {
    background-color: var(--success-color);
    color: white;
    border: none;
}

button#auto-save-btn.active:hover {
    background-color: #3aa8d8;
}



    /* Add this for note window size */
    #note-modal {
        width: 90%;
        max-width: 600px; /* Increased from 400px */
        max-height: 90vh;
    }
    
    #note-content {
        height: 300px; /* Increased from 200px */
        min-height: 300px; /* Ensures minimum height */
        resize: vertical; /* Allows user to resize vertically */
    }
        /* Make the note modal more spacious */
    #note-modal .modal-content {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }
    
    /* Make the note title stand out more */
    #note-item-title {
        font-size: 1.2rem;
        padding: 0.5rem;
        background-color: #f5f7fa;
        border-radius: 6px;
    }
    
    /* Style the textarea better */
    #note-content {
        font-size: 1rem;
        line-height: 1.5;
        padding: 1rem;
    }

/* Floating action buttons - unified style */
#floating-down-btn,
#floating-save-btn,
#floating-load-btn,
#floating-toggle-btn,
#floating-toggleview-btn,
#floating-up-btn {
    position: fixed;
    width: 36px;
    height: 36px;
    font-size: 1.2rem;
    border-radius: 50%;
    border: none;
    background-color: var(--primary-color);
    color: white;
    cursor: pointer;
    z-index: 10;
    opacity: 0.8;
    box-shadow: var(--shadow);
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    left: calc(50% + 400px);
    transform: translateX(10px);
}

/* Individual button positioning */
#floating-down-btn {
    top: calc(30% - 45px); /* 45px above save button */
    transform: translate(-10px, -50%);
}

/* Individual button positioning */
#floating-save-btn {
    top: 30%;
    transform: translate(-10px, -50%);
}

#floating-load-btn {
    top: calc(30% + 45px); /* 45px below save button */
    transform: translate(-10px, -50%);
}

#floating-toggle-btn {
    top: calc(30% + 90px); /* 90px below save button */
    transform: translate(-10px, -50%);
}

#floating-toggleview-btn {
    top: calc(30% + 135px); /* 90px below save button */
    transform: translate(-10px, -50%);
}

#floating-up-btn {
    top: calc(30% + 185px); /* 135px below save button */
    transform: translate(-10px, -50%);
}

/* Individual button colors */
#floating-save-btn,
#floating-load-btn {
    background-color: #28a745; /* Same green as your green-btn class */
    color: white;
}
#floating-save-btn:hover,
#floating-load-btn:hover {
    background-color: #218838; /* Same hover color as your green-btn:hover */
    opacity: 1;
    transform: translate(-10px, -50%) scale(1.1);
}

#floating-toggle-btn {
    background-color: var(--section-color); /* Purple like section buttons */
}
#floating-toggle-btn:hover {
    background-color: #5a189a; /* Darker purple on hover */
}

#floating-down-btn,
#floating-up-btn {
    background-color: rgba(114, 9, 183, 0.2); /* Light purple/pink like scroll buttons */
    color: var(--section-color); /* Purple text */
}
#floating-down-btn:hover,
#floating-up-btn:hover {
    background-color: rgba(114, 9, 183, 0.5); /* More visible purple/pink on hover */
}

#floating-toggleview-btn {
    background-color: #6a5acd; /* Same as the toggle view button */
}
#floating-toggleview-btn:hover {
    background-color: #5a4cbd; /* Darker version on hover */
}


/* Hover effects for all buttons */
#floating-down-btn:hover,
#floating-save-btn:hover,
#floating-load-btn:hover,
#floating-toggle-btn:hover,
#floating-toggleview-btn:hover,
#floating-up-btn:hover {
    opacity: 1;
    transform: translate(-10px, -50%) scale(1.1);
}

/* Mobile responsiveness */
@media (max-width: 700px) {
    #floating-save-btn,
    #floating-load-btn,
    #floating-toggle-btn {
        display: none !important;
    }
}

/* Add these new styles for the sync functionality */
.sync-btn {
    background-color: #ff9800 !important;
}

.sync-btn:hover {
    background-color: #e68900 !important;
}

#sync-modal .modal-content {
    max-width: 500px;
}

#sync-link {
    width: 100%;
    padding: 0.8rem;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    font-size: 0.9rem;
    margin: 1rem 0;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}

.sync-instructions {
    background-color: #f8f9fa;
    padding: 1rem;
    border-radius: 8px;
    margin-top: 1rem;
    font-size: 0.9rem;
}

.sync-instructions h4 {
    color: #ff9800;
    margin-bottom: 0.5rem;
}

.sync-instructions ol {
    padding-left: 1.5rem;
}

.sync-instructions li {
    margin-bottom: 0.5rem;
}

.warning {
    color: var(--danger-color);
    font-weight: 500;
    margin-top: 0.5rem;
}

</style>
</head>
<body>
    <div class="container">
        <h1>Smart To-Do List</h1>
        
        <input type="text" id="title" placeholder="List title...">
        
        <div class="input-group">
            <input type="text" id="new-item" placeholder="Add new task" enterkeyhint="done">
            <button onclick="addItem()">Add</button>
            <button onclick="addItemToTop()">Add (Top)</button>
        </div>
        
        <ul id="todo-list"></ul>
        
        <div id="status"></div>
        

<div class="controls">
    <button class="section-btn" onclick="addSectionBreak()">‚è∏Ô∏è Section</button>
    
    <!-- Desktop buttons -->
    <button class="green-btn desktop-only" onclick="saveToFile()">üíæ Save</button>
    <button class="green-btn desktop-only" onclick="loadFromFile()">üìÇ Load</button>
<!-- üëá Add drag-and-drop loading support  -->
    <button id="drop-button" class="desktop-only secondary">üìÇ Drop File</button>
    <button onclick="toggleAutoSave()" id="auto-save-btn">üîÅ Auto-Save: Off</button>    
    <button class="section-btn" onclick="addSectionToTop()">‚è´ Top Section</button>
    <!-- Mobile buttons (alternative actions)
    <button class="mobile-only" onclick="showExportModal()">üíæ Save</button>
    <button class="mobile-only" onclick="showImportModal()">üìÇ Load</button>  -->
            <button onclick="showExportModal()">üì§ Export</button>
            <button onclick="showImportModal()">üì• Import</button>    
    <button onclick="clearList()">üóëÔ∏è Clear</button>
    <button onclick="toggleAllSections()">üîΩ Toggle All</button>
    <button onclick="printToPDF()">üñ®Ô∏è Print/PDF</button>
    <button onclick="printToPDFWithNotes()">üñ®Ô∏è PDF+Notes</button>
    <button onclick="popoutListWithNotes()">üìã Popout1</button>
    <button onclick="popoutListWithNotes2()">üìã Popout2</button>
    <button onclick="popoutCleanView2()">üëÅÔ∏è CleanView</button>
    <button onclick="toggleCleanView()">üëÅÔ∏è ToggleView</button>
    <button onclick="printVisibleList()">üñ®Ô∏è Print View</button>
    <button onclick="shareList()">üì§ Share</button>
    <button class="sync-btn" onclick="showSyncModal()"title="Sync Across Devices">üîÑ Sync</button>
    <button onclick="showTemplateImport()" class="template-btn">üìã Template</button>
    <button onclick="setDefaultTemplate('office')" class="template-btn">Set Office Default</button> 
    <button onclick="clearDefaultTemplate()" class="danger">Clear Default</button> 
    <button onclick="showHelpModal()" class="help-btn">‚ùì Help</button>
    <button onclick="showDynalistHelp()" class="help-btn">‚ùì Dynalist Help</button>
</div>
<button class="green-btn" onclick="exportAllToDynalist()">üì§ Export to Dynalist</button>
        
        <div id="current-folder"></div>
        
        <div class="saved-lists">
            <h2>Saved Lists</h2>
            <div id="saved-files-container" class="saved-files-container"></div>
        </div>
        
        <div class="footer">
            &copy; 2025 Dr. Wen-Ming Yang Lab. All rights reserved. (m63b7 Sync Across Devices)
        </div>
    </div>

    <!-- Import Modal -->
<div class="import-options">
    <label>
        <input type="checkbox" id="append-import" checked>
        Append to current list
    </label>
</div>

    <!-- Export Modal -->
    <div class="overlay" id="export-overlay"></div>
    <div class="modal" id="export-modal">
        <h3>Export To-Do List</h3>
        <div class="modal-content">
            <div class="export-format">
                <label>
                    <input type="radio" name="export-format" value="markdown" checked>
                    Markdown
                </label>
                <label>
                    <input type="radio" name="export-format" value="html">
                    HTML
                </label>
                <label>
                    <input type="radio" name="export-format" value="plaintext">
                    Plain Text
                </label>
            </div>
            <textarea id="export-content" readonly></textarea>
            <div class="modal-actions">
                <button onclick="copyToClipboard('export-content')">Copy</button>
                <button class="secondary" onclick="hideModal('export')">Close</button>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div class="overlay" id="import-overlay"></div>
    <div class="modal" id="import-modal">
        <h3>Import To-Do List</h3>
        <div class="modal-content">
            <div class="import-format">
                <label>
                    <input type="radio" name="import-format" value="markdown" checked>
                    Markdown
                </label>
                <label>
                    <input type="radio" name="import-format" value="html">
                    HTML
                </label>
                <label>
                    <input type="radio" name="import-format" value="plaintext">
                    Plain Text
                </label>
            </div>
            <textarea id="import-content" placeholder="Paste your list content here..."></textarea>
            <div class="modal-actions">
                <button onclick="importList()">Import</button>
                <button class="secondary" onclick="hideModal('import')">Cancel</button>
            </div>
        </div>
    </div>

<!-- Add the new Sync Modal -->
<div class="overlay" id="sync-overlay"></div>
<div class="modal" id="sync-modal">
    <h3>Sync Across Devices</h3>
    <div class="modal-content">
        <p>Generate a link to share your to-do list across devices:</p>
        <input type="text" id="sync-link" readonly placeholder="Sync link will appear here">
        <div class="modal-actions">
            <button onclick="copySyncLink()">Copy Link</button>
            <button class="secondary" onclick="hideModal('sync')">Close</button>
        </div>
        
        <div class="sync-instructions">
            <h4>How to sync across devices:</h4>
            <ol>
                <li>Click the "Sync Across Devices" button (orange button)</li>
                <li>Copy the generated link using the "Copy Link" button</li>
                <li>Send the link to your other device via messaging app, email, or any method you prefer</li>
                <li>Open the link on your other device (phone, tablet, or computer)</li>
                <li>Confirm that you want to load the tasks when prompted</li>
            </ol>
            <p class="warning">Important Notes:</p>
            <ul>
                <li>The link contains all your task data, so only share it with devices you trust</li>
                <li>This is a one-way sync - changes made on one device won't automatically update on others</li>
                <li>To sync updated tasks, generate a new link and open it on your other devices</li>
                <li>The link can be quite long because it contains all your task data</li>
            </ul>
        </div>
    </div>
</div>

<!-- Add the Load from Link Modal -->
<div class="overlay" id="load-overlay"></div>
<div class="modal" id="load-modal">
    <h3>Load Tasks from Link?</h3>
    <div class="modal-content">
        <p>This will replace your current tasks with the ones from the link.</p>
        <div class="modal-actions">
            <button onclick="loadFromLink()">Yes, Load Tasks</button>
            <button class="secondary" onclick="hideLoadModal()">Cancel</button>
        </div>
    </div>
</div>

    <script>
let dynalistApiKey = localStorage.getItem('dynalistApiKey') || '';
let dynalistDocId = localStorage.getItem('dynalistDocId') || '';
// File system variables
    let directoryHandle;
    let fileHandles = {};
    let draggedItem = null;
    let touchStartY = 0;
    let isDragging = false;
    let cleanViewWindow = null; // Track the clean view window
    
    // Initialize
document.addEventListener('DOMContentLoaded', function() {
    updateTitleWithCurrentDate();
    checkForSavedFiles();
    setupDirectEditing();
    setupDragAndDrop();
    setupMobileEvents();
    checkUrlForData();
    
    // Add this check for default template
    const defaultTemplate = localStorage.getItem('defaultTemplate');
    if (defaultTemplate && templates[defaultTemplate]) {
        loadTemplate(defaultTemplate);
    } else {
        // Show empty state if no default template
        const todoList = document.getElementById('todo-list');
        if (todoList.children.length === 0) {
            todoList.innerHTML = '<div class="empty-state">No tasks yet</div>';
        }
    }
    
    // Add event listeners for format changes
    document.querySelectorAll('input[name="export-format"]').forEach(radio => {
        radio.addEventListener('change', updateExportContent);
    });

// üëá Add drag-and-drop loading support
const dropButton = document.getElementById('drop-button');

if (dropButton) {
    // Highlight button on drag over
    dropButton.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropButton.classList.add('dragover');
    });

    dropButton.addEventListener('dragleave', () => {
        dropButton.classList.remove('dragover');
    });

    dropButton.addEventListener('drop', async (e) => {
        e.preventDefault();
        dropButton.classList.remove('dragover');

        const file = e.dataTransfer.files[0];
        if (!file || (!file.name.endsWith('.json') && !file.name.endsWith('.todo'))) {
            showStatus('Invalid file format. Only .json or .todo allowed.', 'error');
            return;
        }

        try {
            const text = await file.text();
            const data = JSON.parse(text);

            document.getElementById('title').value = data.title || 'Imported List';
            const todoList = document.getElementById('todo-list');
            todoList.innerHTML = '';

            if (Array.isArray(data.items)) {
                data.items.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'todo-item';
                    li.draggable = true;
                    if (item.isSection) {
    li.classList.add('section-break');

    // üîΩ Add the toggle button for sections
    li.innerHTML = `
        <span class="drag-handle">‚ò∞</span>
        <button class="toggle-btn" onclick="toggleSectionItems(this)">‚ñæ</button>
        <span class="item-text">${item.text}</span>
        <textarea class="item-edit" rows="1">${item.text}</textarea>
        <button class="delete-btn">√ó</button>
    `;
}

                    if (item.completed) li.classList.add('completed');

const note = item.note || '';
li.innerHTML = `
  <span class="drag-handle">‚ò∞</span>
  <input type="checkbox" class="item-checkbox" ${item.completed ? 'checked' : ''}>
  <span class="note-indicator" style="${note.trim() ? 'opacity:1' : 'opacity:0'}" data-note="${note}"></span>
  <span class="item-text">${item.text}</span>
  <textarea class="item-edit" rows="1">${item.text}</textarea>
  <button class="note-btn ${note.trim() ? 'has-note' : ''}" onclick="showNoteModal(this)">üìù</button>
  <span class="note-preview" style="display: none;">${note}</span>
  <button class="indent-btn" onclick="indentItem(this)">‚á•</button>
  <button class="outdent-btn" onclick="outdentItem(this)">‚á§</button>
  <button class="delete-btn">√ó</button>
`;

// Add note data if it exists
if (note.trim()) {
    li.dataset.note = note;
}

li.dataset.indent = item.indent || 0;
li.style.marginLeft = `${(item.indent || 0) * 1.5}rem`;


                    // Add note data if it exists
                    if (item.note) {
                        li.dataset.note = item.note;
                        const noteBtn = li.querySelector('.note-btn');
                        if (noteBtn && item.note.trim()) {
                            noteBtn.style.fontWeight = 'bold';
                        }
                    }

                    todoList.appendChild(li);
                });

                showStatus(`Loaded "${file.name}" via drag & drop`, 'success');
            } else {
                showStatus('Invalid file structure', 'error');
            }

        } catch (err) {
            console.error(err);
            showStatus('Failed to load file', 'error');
        }
    });
}

});

    function setupMobileEvents() {
        // Prevent zooming on double-tap
        let lastTap = 0;
        document.addEventListener('touchend', function(e) {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            if (tapLength < 300 && tapLength > 0) {
                e.preventDefault();
            }
            lastTap = currentTime;
        }, { passive: false });
        
        // Better handling for virtual keyboard
        const inputs = document.querySelectorAll('input[type="text"], textarea');
        inputs.forEach(input => {
            input.addEventListener('focus', function() {
                setTimeout(() => {
                    this.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 300);
            });
        });
    }

    function setupDragAndDrop() {
        const list = document.getElementById('todo-list');
        
        // For desktop
        list.addEventListener('dragstart', function(e) {
            if (e.target.classList.contains('todo-item')) {
                draggedItem = e.target;
                e.target.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', '');
            }
        });
        
        list.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const targetItem = e.target.closest('.todo-item');
            if (targetItem && targetItem !== draggedItem) {
                const rect = targetItem.getBoundingClientRect();
                const next = (e.clientY - rect.top) / (rect.bottom - rect.top) > 0.5;
                list.insertBefore(draggedItem, next ? targetItem.nextSibling : targetItem);
            }
        });
        
list.addEventListener('dragend', function(e) {
    if (e.target.classList.contains('todo-item')) {
        const li = e.target;
        li.classList.remove('dragging');
        draggedItem = null;

        // Auto-indent based on previous item
        const prev = li.previousElementSibling;
        if (prev && prev.classList.contains('todo-item')) {
            const prevIndent = parseInt(prev.dataset.indent || "0");
            li.dataset.indent = prevIndent;
            li.style.marginLeft = `${prevIndent * 1.5}rem`;
        } else {
            // First item ‚Üí no indent
            li.dataset.indent = 0;
            li.style.marginLeft = '0rem';
        }

        saveTodo();
        
        // Ensure toggle buttons are updated after drag
        ensureToggleButtons();
    }
});

        
        // For touch devices
        list.addEventListener('touchstart', function(e) {
            const item = e.target.closest('.todo-item');
            if (!item) return;
            
            // Check if we're touching a delete button or checkbox
            if (e.target.closest('.delete-btn') || e.target.closest('.item-checkbox')) {
                return;
            }
            
            // Check if we're touching the drag handle
            if (e.target.closest('.drag-handle')) {
                touchStartY = e.touches[0].clientY;
                isDragging = true;
                item.classList.add('dragging');
                e.preventDefault();
                return;
            }
            
            // Otherwise prepare for possible text edit
            touchStartY = e.touches[0].clientY;
            isDragging = false;
        }, { passive: false });
        
        list.addEventListener('touchmove', function(e) {
            if (!isDragging) return;
            
            const touchY = e.touches[0].clientY;
            const deltaY = touchY - touchStartY;
            
            const item = document.querySelector('.todo-item.dragging');
            if (!item) return;
            
            // Move the dragged item visually
            item.style.transform = `translateY(${deltaY}px)`;
            
            // Find the item we're hovering over
            const hoverY = e.touches[0].clientY;
            const items = Array.from(list.children).filter(i => i !== item);
            
            for (const targetItem of items) {
                const rect = targetItem.getBoundingClientRect();
                const middle = rect.top + rect.height / 2;
                
                if (hoverY < middle) {
                    list.insertBefore(item, targetItem);
                    break;
                } else if (targetItem === items[items.length - 1]) {
                    list.appendChild(item);
                }
            }
            
            e.preventDefault();
        }, { passive: false });
        
        list.addEventListener('touchend', function(e) {
            const item = document.querySelector('.todo-item.dragging');
            if (item) {
                item.classList.remove('dragging');
                item.style.transform = '';
                isDragging = false;
                e.preventDefault();
            }
        }, { passive: false });
    }

    function setupDirectEditing() {
        const todoList = document.getElementById('todo-list');
        
        // Handle clicks and touches
        todoList.addEventListener('click', handleItemClick);
        //todoList.addEventListener('touchend', handleItemTouch, { passive: false });
todoList.addEventListener('touchstart', handleItemTouchStart, { passive: false });
todoList.addEventListener('touchend', handleItemTouchEnd, { passive: false });

let touchTarget = null;

function handleItemTouchStart(e) {
    const touch = e.touches[0];
    touchTarget = document.elementFromPoint(touch.clientX, touch.clientY);
}

function handleItemTouchEnd(e) {
    if (!touchTarget) return;

    const checkbox = touchTarget.closest('.item-checkbox');
    const deleteBtn = touchTarget.closest('.delete-btn');
    const textSpan = touchTarget.closest('.item-text');

    if (checkbox) {
        e.preventDefault();
        checkbox.checked = !checkbox.checked;
        toggleComplete(checkbox);
    } else if (deleteBtn) {
        e.preventDefault();
        deleteItem(deleteBtn);
    } else if (textSpan) {
        e.preventDefault();
        e.stopPropagation(); // prevent input from immediately blurring
        startEditing(textSpan.closest('.todo-item'));
    }

    touchTarget = null;
}

        
        function handleItemClick(e) {
            // Don't edit if dragging
            if (document.querySelector('.todo-item.dragging')) return;
            
            // Handle checkbox clicks
            if (e.target.classList.contains('item-checkbox')) {
                setTimeout(() => {
                    toggleComplete(e.target);
                }, 0);
                return;
            }
            
            // Handle delete button
            if (e.target.classList.contains('delete-btn')) {
                deleteItem(e.target);
                return;
            }
            
            // Handle item text editing
            const textSpan = e.target.closest('.item-text');
            if (textSpan && !isDragging) {
                startEditing(textSpan.closest('.todo-item'));
            }
        }
        
        function handleItemTouch(e) {
            if (isDragging) return;
            
            const touch = e.changedTouches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            
            // Handle checkbox
            const checkbox = target.closest('.item-checkbox');
            if (checkbox) {
                e.preventDefault();
                checkbox.checked = !checkbox.checked;
                toggleComplete(checkbox);
                return;
            }
            
            // Handle delete button
            const deleteBtn = target.closest('.delete-btn');
            if (deleteBtn) {
                e.preventDefault();
                deleteItem(deleteBtn);
                return;
            }
            
            // Handle item text editing
            const textSpan = target.closest('.item-text');
            if (textSpan) {
                e.preventDefault();
                startEditing(textSpan.closest('.todo-item'));
            }
        }
        
        function startEditing(li) {
            const textSpan = li.querySelector('.item-text');
            const editInput = li.querySelector('.item-edit');
            
            textSpan.style.display = 'none';
            editInput.style.display = 'block';
            editInput.value = textSpan.textContent;
            
            // Focus and open keyboard
setTimeout(() => {
    editInput.focus();
    editInput.setSelectionRange(editInput.value.length, editInput.value.length);
    
    editInput.addEventListener('blur', saveEdit);
    editInput.addEventListener('keyup', handleKeyUp);

// Handle Tab and Shift+Tab for indent/outdent
editInput.addEventListener('keydown', function(e) {
    if (e.key === 'Tab') {
        e.preventDefault(); // Prevent default tab action (focus change)

        if (e.shiftKey) {
            // Shift + Tab ‚Üí Outdent
            const outdentBtn = li.querySelector('.outdent-btn');
            if (outdentBtn) outdentItem(outdentBtn);
        } else {
            // Tab ‚Üí Indent
            const indentBtn = li.querySelector('.indent-btn');
            if (indentBtn) indentItem(indentBtn);
        }

        // Refocus input after indent change
        editInput.focus();
        editInput.setSelectionRange(editInput.value.length, editInput.value.length);
    }
});


    if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
        const fakeInput = document.createElement('input');
        fakeInput.style.position = 'absolute';
        fakeInput.style.opacity = 0;
        fakeInput.style.height = 0;
        fakeInput.style.zIndex = -1;
        document.body.appendChild(fakeInput);
        fakeInput.focus();
        setTimeout(() => {
            document.body.removeChild(fakeInput);
            editInput.focus();
        }, 100);
    }
}, 200); // increase delay for better iOS support

            
            function saveEdit() {
                const newText = editInput.value.trim();
                if (newText) {
                    textSpan.textContent = newText;
                    showStatus(li.classList.contains('section-break') ? 'Section updated' : 'Task updated', 'success');
                } else if (li.classList.contains('blank-item')) {
                    li.remove();
                    if (todoList.children.length === 0) {
                        todoList.innerHTML = '<div class="empty-state">No tasks yet</div>';
                    }
                }
                textSpan.style.display = 'block';
                editInput.style.display = 'none';
                
                // Clean up event listeners
                editInput.removeEventListener('blur', saveEdit);
                editInput.removeEventListener('keyup', handleKeyUp);
                saveTodo(); // This will check autoSaveEnabled internally
            }
            
// Inside setupDirectEditing(), modify the handleKeyUp function:
function handleKeyUp(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        saveEdit();
        
        // Create new item with same indent level
        const newItem = createBlankItem(li);
        if (li.dataset.indent) {
            newItem.dataset.indent = li.dataset.indent;
            newItem.style.marginLeft = li.style.marginLeft;
        }
    }
    if (e.key === 'Escape') {
        textSpan.style.display = 'block';
        editInput.style.display = 'none';
    }
    // Remove the Tab key handling here since it's already handled by the indent/outdent buttons
}

            
            // Delay blur to avoid immediate cancel on iOS
setTimeout(() => {
    editInput.addEventListener('blur', saveEdit);
}, 300);

            editInput.addEventListener('keyup', handleKeyUp);
        }
        
        // Keep existing blank item cleanup
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.todo-item') && !e.target.closest('.input-group')) {
                const blankItems = document.querySelectorAll('.todo-item.blank-item');
                blankItems.forEach(item => {
                    if (item.querySelector('.item-edit').value.trim() === '') {
                        item.remove();
                        if (todoList.children.length === 0) {
                            todoList.innerHTML = '<div class="empty-state">No tasks yet</div>';
                        }
                    }
                });
            }
        });
    }

function createBlankItem(afterItem) {
    const li = document.createElement('li');
    li.className = 'todo-item blank-item';
    li.draggable = true;

    // Get indent from the previous item
    const prevIndent = parseInt(afterItem.dataset.indent || "0");
    li.dataset.indent = prevIndent;
    li.style.marginLeft = `${prevIndent * 1.5}rem`;

    li.innerHTML = `
        <span class="drag-handle">‚ò∞</span>
        <input type="checkbox" class="item-checkbox">
        <span class="note-indicator" style="opacity:0"></span>
        <span class="item-text"></span>
        <textarea class="item-edit" rows="1"></textarea>
        <button class="note-btn" onclick="showNoteModal(this)">üìù</button>
         
        <button class="indent-btn" onclick="indentItem(this)">‚á•</button>
        <button class="outdent-btn" onclick="outdentItem(this)">‚á§</button>
        <button class="delete-btn">√ó</button>
    `;

    // Initialize note preview functionality
    const noteBtn = li.querySelector('.note-btn');
    const notePreview = li.querySelector('.note-preview');
    const noteIndicator = li.querySelector('.note-indicator');
    
    noteBtn.addEventListener('mouseenter', () => {
        if (li.dataset.note) {
            notePreview.textContent = li.dataset.note;
            notePreview.style.display = 'block';
        }
    });
    
    noteBtn.addEventListener('mouseleave', () => {
        notePreview.style.display = 'none';
    });

    // Set up note indicator hover
    if (noteIndicator) {
        noteIndicator.addEventListener('mouseenter', () => {
            if (li.dataset.note) {
                notePreview.textContent = li.dataset.note;
                notePreview.style.display = 'block';
            }
        });
        
        noteIndicator.addEventListener('mouseleave', () => {
            notePreview.style.display = 'none';
        });
    }

    afterItem.parentNode.insertBefore(li, afterItem.nextSibling);

    // Focus on the new item's edit field
    const editInput = li.querySelector('.item-edit');
    const textSpan = li.querySelector('.item-text');
    li.querySelector('.item-text').style.display = 'none';
    editInput.style.display = 'block';
    editInput.focus();

    // Event handlers
    function saveEdit() {
        const newText = editInput.value.trim();
        if (newText) {
            textSpan.textContent = newText;
            li.classList.remove('blank-item');
            showStatus('Task updated', 'success');
        } else {
            li.remove();
            if (todoList.children.length === 0) {
                todoList.innerHTML = '<div class="empty-state">No tasks yet</div>';
            }
            return;
        }
        textSpan.style.display = 'block';
        editInput.style.display = 'none';
        
        // Clean up event listeners
        editInput.removeEventListener('blur', saveEdit);
        editInput.removeEventListener('keydown', handleKeyUp);
        saveTodo(); // This will check autoSaveEnabled internally
    }

function handleKeyUp(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        saveEdit();
        
        // Create new item with same indent level
        const newItem = createBlankItem(li);
        if (li.dataset.indent) {
            newItem.dataset.indent = li.dataset.indent;
            newItem.style.marginLeft = li.style.marginLeft;
        }
    }
    if (e.key === 'Escape') {
        textSpan.style.display = 'block';
        editInput.style.display = 'none';
    }
    if (e.key === 'Tab') {
        e.preventDefault();
        const currentIndent = parseInt(li.dataset.indent || "0");
        
        if (e.shiftKey) {
            // Shift + Tab ‚Üí Outdent
            if (currentIndent > 0) {
                li.dataset.indent = currentIndent - 1;
                li.style.marginLeft = `${(currentIndent - 1) * 1.5}rem`;
            }
        } else {
            // Tab ‚Üí Indent (up to 5 levels)
            if (currentIndent < 5) {
                li.dataset.indent = currentIndent + 1;
                li.style.marginLeft = `${(currentIndent + 1) * 1.5}rem`;
            }
        }
        editInput.focus();
    }
    
    ensureToggleButtons();
}

    editInput.addEventListener('blur', saveEdit);
    editInput.addEventListener('keydown', handleKeyUp);
    
    return li;
}

        function updateTitleWithCurrentDate() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const dayName = days[today.getDay()];
            document.getElementById('title').value = `Tasks ${year}${month}${day}-${dayName}`;
        }

function addItem() {
    const input = document.getElementById('new-item');
    const text = input.value.trim();
    if (text === '') {
        showStatus('Please enter a task', 'warning');
        return;
    }

    const li = document.createElement('li');
    li.className = 'todo-item';
    li.draggable = true;
    li.dataset.indent = "0";
    li.style.marginLeft = '0rem';

    li.innerHTML = `
        <span class="drag-handle">‚ò∞</span>
        <input type="checkbox" class="item-checkbox">
        <span class="note-indicator" style="opacity:0"></span>
        <span class="item-text">${text}</span>
        <textarea class="item-edit" rows="1">${text}</textarea>
        <button class="note-btn" onclick="showNoteModal(this)">üìù</button>
         
        <button class="indent-btn" onclick="indentItem(this)">‚á•</button>
        <button class="outdent-btn" onclick="outdentItem(this)">‚á§</button>
        <button class="delete-btn">√ó</button>
    `;

    // Initialize note preview functionality
    const noteBtn = li.querySelector('.note-btn');
    const notePreview = li.querySelector('.note-preview');
    
    noteBtn.addEventListener('mouseenter', () => {
        if (li.dataset.note) {
            notePreview.textContent = li.dataset.note;
            notePreview.style.display = 'block';
        }
    });
    
    noteBtn.addEventListener('mouseleave', () => {
        notePreview.style.display = 'none';
    });

    // Remove empty state if present
    const todoList = document.getElementById('todo-list');
    if (todoList.querySelector('.empty-state')) {
        todoList.innerHTML = '';
    }

    todoList.appendChild(li);
    input.value = '';
    input.focus();
    showStatus('Task added', 'success');
    
    ensureToggleButtons();
    saveTodo(); // This will check autoSaveEnabled internally
}


function addSectionBreak() {
    const li = document.createElement('li');
    li.className = 'todo-item section-break';
    li.draggable = true;
    li.innerHTML = `
        <span class="drag-handle">‚ò∞</span>
        <button class="toggle-btn" onclick="toggleSectionItems(this)">‚ñæ</button>
        <span class="item-text">NewSection</span>
        <textarea class="item-edit" rows="1">NewSection</textarea>
        <button class="delete-btn">√ó</button>
    `;
    
    // Remove empty state if present
    const todoList = document.getElementById('todo-list');
    if (todoList.querySelector('.empty-state')) {
        todoList.innerHTML = '';
    }
    
    todoList.appendChild(li);
    showStatus('Section added', 'success');
    
    // Ensure toggle button is properly set up
    ensureToggleButtons();
    saveTodo(); // This will check autoSaveEnabled internally
}
        
function addSectionToTop() {
    const todoList = document.getElementById('todo-list');
    
    // Remove empty state if present
    if (todoList.querySelector('.empty-state')) {
        todoList.innerHTML = '';
    }
    
    // Create the section
    const section = document.createElement('li');
    section.className = 'todo-item section-break';
    section.draggable = true;
    section.innerHTML = `
        <span class="drag-handle">‚ò∞</span>
        <button class="toggle-btn" onclick="toggleSectionItems(this)">‚ñæ</button>
        <span class="item-text"></span>
        <textarea class="item-edit" rows="1" placeholder="Section title..."></textarea>
        <button class="delete-btn">√ó</button>
    `;
    
    // Insert at the top
    if (todoList.firstChild) {
        todoList.insertBefore(section, todoList.firstChild);
    } else {
        todoList.appendChild(section);
    }
    
    // Set up section editing
    const sectionText = section.querySelector('.item-text');
    const sectionEdit = section.querySelector('.item-edit');
    
    sectionText.style.display = 'none';
    sectionEdit.style.display = 'block';
    sectionEdit.focus();
    
    sectionEdit.addEventListener('blur', function() {
        const newText = sectionEdit.value.trim();
        if (newText) {
            sectionText.textContent = newText;
            sectionText.style.display = 'block';
            sectionEdit.style.display = 'none';
        } else {
            section.remove();
            checkEmptyState();
        }
    });
    
    sectionEdit.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const newText = sectionEdit.value.trim();
            if (newText) {
                sectionText.textContent = newText;
                sectionText.style.display = 'block';
                sectionEdit.style.display = 'none';
                
                // Create first item below with explicit 0 indent level
                const newItem = createItemBelow(section, 0);
                
                // Focus on the new item's edit field
                const newEditInput = newItem.querySelector('.item-edit');
                setTimeout(() => newEditInput.focus(), 10);
            } else {
                section.remove();
                checkEmptyState();
            }
        }
    });
    
    // Ensure toggle button is properly set up
    ensureToggleButtons();
    saveTodo(); // This will check autoSaveEnabled internally
}

function createItemBelow(afterItem, indentLevel = 0) {
    const li = document.createElement('li');
    li.className = 'todo-item';
    li.draggable = true;
    li.dataset.indent = indentLevel;
    li.style.marginLeft = `${indentLevel * 1.5}rem`;
    
    li.innerHTML = `
        <span class="drag-handle">‚ò∞</span>
        <input type="checkbox" class="item-checkbox">
        <span class="note-indicator" style="opacity:0"></span>
        <span class="item-text"></span>
        <textarea class="item-edit" rows="1" placeholder="Task description..."></textarea>
        <button class="note-btn" onclick="showNoteModal(this)">üìù</button>
         
        <button class="indent-btn" onclick="indentItem(this)">‚á•</button>
        <button class="outdent-btn" onclick="outdentItem(this)">‚á§</button>
        <button class="delete-btn">√ó</button>
    `;
    
    afterItem.parentNode.insertBefore(li, afterItem.nextSibling);
    
    const textSpan = li.querySelector('.item-text');
    const editInput = li.querySelector('.item-edit');
    
    textSpan.style.display = 'none';
    editInput.style.display = 'block';
    editInput.focus();
    
    // Handle both blur and Enter key
    const handleInputCompletion = () => {
        const newText = editInput.value.trim();
        if (newText) {
            textSpan.textContent = newText;
            textSpan.style.display = 'block';
            editInput.style.display = 'none';
        } else {
            li.remove();
            checkEmptyState();
        }
    };
    
    editInput.addEventListener('blur', handleInputCompletion);
    
    editInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleInputCompletion();
            
            // Only create new item if text was entered
            if (editInput.value.trim()) {
                const currentIndent = parseInt(li.dataset.indent || "0");
				createItemBelow(li, currentIndent);// Pass the same indent level
            }
        }
        if (e.key === 'Tab') {
            e.preventDefault();
            if (e.shiftKey) {
                const outdentBtn = li.querySelector('.outdent-btn');
                if (outdentBtn) outdentItem(outdentBtn);
            } else {
                const indentBtn = li.querySelector('.indent-btn');
                if (indentBtn) indentItem(indentBtn);
            }
            editInput.focus();
        }
    });
    
    
    return li;
}

function checkEmptyState() {
    const todoList = document.getElementById('todo-list');
    if (todoList.children.length === 0) {
        todoList.innerHTML = '<div class="empty-state">No tasks yet</div>';
    }
}
        function toggleComplete(checkbox) {
            const li = checkbox.closest('.todo-item');
            li.classList.toggle('completed', checkbox.checked);
        }

        function deleteItem(button) {
            const li = button.closest('.todo-item');
            li.style.transform = 'translateX(-100%)';
            li.style.opacity = '0';
            setTimeout(() => {
                li.remove();
                
                // Show empty state if no items left
                const todoList = document.getElementById('todo-list');
                if (todoList.children.length === 0) {
                    todoList.innerHTML = '<div class="empty-state">No tasks yet</div>';
                }
                
                showStatus(li.classList.contains('section-break') ? 'Section deleted' : 'Task deleted', 'warning');
            }, 200);
            
            ensureToggleButtons();
            
            saveTodo(); // This will check autoSaveEnabled internally
        }

        /* ========== IMPORT/EXPORT FUNCTIONALITY ========== */
        function showExportModal() {
            showModal('export');
            updateExportContent();
        }

        function showImportModal() {
            showModal('import');
            document.getElementById('import-content').value = '';
        }

        function showModal(type) {
            document.getElementById(`${type}-overlay`).style.display = 'block';
            document.getElementById(`${type}-modal`).style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        function hideModal(type) {
            document.getElementById(`${type}-overlay`).style.display = 'none';
            document.getElementById(`${type}-modal`).style.display = 'none';
            document.body.style.overflow = '';
        }

function updateExportContent() {
    const format = document.querySelector('input[name="export-format"]:checked').value;
    const title = document.getElementById('title').value || 'Untitled List';
    let content = '';
    
    if (format === 'markdown') {
        content = `# ${title}\n\n`;
        document.querySelectorAll('#todo-list .todo-item').forEach(item => {
            const indent = parseInt(item.dataset.indent || "0");
            const indentSpaces = ' '.repeat(indent * 4); // 4 spaces per indent level
            const text = item.querySelector('.item-text').textContent;
            const note = item.dataset.note || '';
            
            if (item.classList.contains('section-break')) {
                content += `${indentSpaces}## ${text}\n\n`;
            } else {
                const checked = item.querySelector('.item-checkbox')?.checked ? 'x' : ' ';
                content += `${indentSpaces}- [${checked}] ${text}\n`;
                if (note) {
                    content += `${indentSpaces}  Note: ${note}\n`;
                }
            }
        });
    } 
    else if (format === 'html') {
        content = `<h1>${title}</h1>\n<ul>\n`;
        document.querySelectorAll('#todo-list .todo-item').forEach(item => {
            const indent = parseInt(item.dataset.indent || "0");
            const indentStyle = ` style="margin-left: ${indent * 20}px"`;
            const text = item.querySelector('.item-text').textContent;
            const note = item.dataset.note || '';
            
            if (item.classList.contains('section-break')) {
                content += `</ul>\n<h2${indentStyle}>${text}</h2>\n<ul>\n`;
            } else {
                const checked = item.querySelector('.item-checkbox')?.checked ? ' checked' : '';
                content += `  <li${indentStyle}><input type="checkbox"${checked}> ${text}`;
                if (note) {
                    content += `<div class="note">Note: ${note}</div>`;
                }
                content += `</li>\n`;
            }
        });
        content += '</ul>';
    } 
    else { // plaintext
        content = `${title}\n${'='.repeat(title.length)}\n\n`;
        document.querySelectorAll('#todo-list .todo-item').forEach(item => {
            const indent = parseInt(item.dataset.indent || "0");
            const indentSpaces = ' '.repeat(indent * 2); // 2 spaces per indent level
            const text = item.querySelector('.item-text').textContent;
            const note = item.dataset.note || '';
            
            if (item.classList.contains('section-break')) {
                content += `\n${indentSpaces}${text}\n${indentSpaces}${'-'.repeat(text.length)}\n\n`;
            } else {
                const checked = item.querySelector('.item-checkbox')?.checked ? '[‚úì]' : '[ ]';
                content += `${indentSpaces}${checked} ${text}\n`;
                if (note) {
                    content += `${indentSpaces}  Note: ${note}\n`;
                }
            }
        });
    }
    
    document.getElementById('export-content').value = content;
}

function importList() {
    const content = document.getElementById('import-content').value.trim();
    if (!content) {
        showStatus('No content to import', 'warning');
        return;
    }
    
    const format = document.querySelector('input[name="import-format"]:checked').value;
    const appendMode = document.getElementById('append-import').checked;
    
    try {
        let items = [];
        let importedTitle = document.getElementById('title').value || "Imported List";
        
        if (format === 'markdown') {
            const lines = content.split('\n');
            const firstLine = lines[0].trim();
            if (firstLine.startsWith('# ')) {
                importedTitle = firstLine.substring(2).trim();
            }
            
            let currentIndent = 0;
            let currentNote = '';
            let currentItem = null;
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                const fullLine = lines[i];
                
                const leadingSpaces = fullLine.match(/^ */)[0].length;
                currentIndent = Math.min(Math.floor(leadingSpaces / 4), 5); // Clamp to 5 levels
                
                if (line.startsWith('Note:')) {
                    currentNote = line.substring(5).trim();
                    continue;
                }
                
                if (line.startsWith('## ')) {
                    items.push({
                        text: line.substring(3).trim(),
                        isSection: true,
                        indent: currentIndent,
                        note: currentNote
                    });
                    currentNote = '';
                } else if (line.match(/^-\s*\[[ xX]\]/)) {
                    const match = line.match(/^-\s*\[(.)\]\s*(.*)$/);
                    if (match) {
                        currentItem = {
                            text: match[2],
                            completed: match[1].toLowerCase() === 'x',
                            isSection: false,
                            indent: currentIndent,
                            note: currentNote
                        };
                        items.push(currentItem);
                        currentNote = '';
                    }
                }
            }
        } else if (format === 'html') {
            const parser = new DOMParser();
            const doc = parser.parseFromString(content, 'text/html');
            const titleEl = doc.querySelector('h1');
            if (titleEl) importedTitle = titleEl.textContent;
            
            let currentIndent = 0;
            
            doc.querySelectorAll('h2, li').forEach(el => {
                if (el.tagName === 'H2') {
                    const marginLeft = el.style.marginLeft;
                    currentIndent = marginLeft ? Math.min(parseInt(marginLeft) / 20, 5) : 0;
                    items.push({
                        text: el.textContent,
                        isSection: true,
                        indent: currentIndent
                    });
                } else {
                    const marginLeft = el.style.marginLeft;
                    currentIndent = marginLeft ? Math.min(parseInt(marginLeft) / 20, 5) : 0;
                    
                    const checkbox = el.querySelector('input[type="checkbox"]');
                    const noteEl = el.querySelector('.note');
                    
                    items.push({
                        text: el.textContent.replace(checkbox?.outerHTML || '', '').trim(),
                        completed: checkbox?.checked || false,
                        isSection: false,
                        indent: currentIndent,
                        note: noteEl ? noteEl.textContent.replace('Note:', '').trim() : ''
                    });
                }
            });
        } else {
            const lines = content.split('\n');
            const firstLine = lines[0].trim();
            if (!firstLine.startsWith('[') && !firstLine.startsWith('-')) {
                importedTitle = firstLine;
            }
            
            let currentIndent = 0;
            let currentNote = '';
            let currentItem = null;
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                const fullLine = lines[i];
                
                const leadingSpaces = fullLine.match(/^ */)[0].length;
                currentIndent = Math.min(Math.floor(leadingSpaces / 2), 5);
                
                if (line.startsWith('Note:')) {
                    currentNote = line.substring(5).trim();
                    continue;
                }
                
                if (line && !line.startsWith('[') && !line.startsWith('-') && 
                    i < lines.length - 1 && lines[i+1].trim().match(/^-+$/)) {
                    items.push({
                        text: line,
                        isSection: true,
                        indent: currentIndent,
                        note: currentNote
                    });
                    i++;
                    currentNote = '';
                } else if (line.startsWith('[‚úì]') || line.startsWith('[ ]')) {
                    currentItem = {
                        text: line.substring(3).trim(),
                        completed: line.startsWith('[‚úì]'),
                        isSection: false,
                        indent: currentIndent,
                        note: currentNote
                    };
                    items.push(currentItem);
                    currentNote = '';
                } else if (line.startsWith('- [‚úì]') || line.startsWith('- [ ]')) {
                    currentItem = {
                        text: line.substring(5).trim(),
                        completed: line.startsWith('- [‚úì]'),
                        isSection: false,
                        indent: currentIndent,
                        note: currentNote
                    };
                    items.push(currentItem);
                    currentNote = '';
                }
            }
        }
        
        const todoList = document.getElementById('todo-list');
        
        if (todoList.querySelector('.empty-state')) {
            todoList.innerHTML = '';
        }
        
        if (!appendMode) {
            document.getElementById('title').value = importedTitle;
            if (!appendMode && items.length > 0) {
                todoList.innerHTML = '';
            }
        }
        
        if (items.length === 0) {
            showStatus('No tasks found in import', 'warning');
        } else {
            items.forEach(item => {
                const indentLevel = Math.min(Math.max(item.indent || 0, 0), 5);
                
               if (item.isSection) {
    const li = document.createElement('li');
    li.className = 'todo-item section-break';
    li.draggable = true;
    li.dataset.indent = indentLevel;
    li.style.marginLeft = `${indentLevel * 1.5}rem`;
    li.innerHTML = `
        <span class="drag-handle">‚ò∞</span>
        <button class="toggle-btn" onclick="toggleSectionItems(this)">‚ñæ</button>
        <span class="item-text">${item.text}</span>
        <textarea class="item-edit" rows="1">${item.text}</textarea>
        <button class="delete-btn">√ó</button>
    `;
    todoList.appendChild(li);
} else {
                    const li = document.createElement('li');
                    li.className = 'todo-item';
                    li.draggable = true;
                    if (item.completed) li.classList.add('completed');
                    li.dataset.indent = indentLevel;
                    li.style.marginLeft = `${indentLevel * 1.5}rem`;
                    
                    if (item.note) {
                        li.dataset.note = item.note;
                    }
                    
                    li.innerHTML = `
                        <span class="drag-handle">‚ò∞</span>
                        <input type="checkbox" class="item-checkbox" ${item.completed ? 'checked' : ''}>
                        <span class="note-indicator" style="${item.note && item.note.trim() ? 'opacity:1' : 'opacity:0'}" data-note="${item.note || ''}"></span>
                        <span class="item-text">${item.text}</span>
                        <textarea class="item-edit" rows="1">${item.text}</textarea>
                        <button class="note-btn ${item.note ? 'has-note' : ''}" onclick="showNoteModal(this)">üìù</button>
                        <span class="note-preview" style="display: none;">${item.note || ''}</span>
                        <button class="indent-btn" onclick="indentItem(this)">‚á•</button>
                        <button class="outdent-btn" onclick="outdentItem(this)">‚á§</button>
                        <button class="delete-btn">√ó</button>
                    `;
                    todoList.appendChild(li);
                }
            });
            
            showStatus(`Imported ${items.length} items (${appendMode ? 'appended' : 'replaced'})`, 'success');
        }
        
        hideModal('import');
    } catch (error) {
        showStatus('Error importing list: ' + error.message, 'error');
        console.error(error);
    }
    
    ensureToggleButtons();
}

        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            element.select();
            
            navigator.clipboard.writeText(element.value).then(() => {
                showStatus('Copied to clipboard!', 'success');
                hideModal('export');
            }).catch(err => {
                showStatus('Failed to copy: ' + err, 'error');
            });
        }

// clear list
function clearList() {
    const todoList = document.getElementById('todo-list');
    
    // Check if there are items to clear
    if (todoList.children.length === 0 || 
        (todoList.children.length === 1 && todoList.querySelector('.empty-state'))) {
        showStatus('List is already empty', 'warning');
        return;
    }
    
    // Confirm before clearing
    if (confirm('Are you sure you want to clear the entire list?')) {
        // Clear all items
        todoList.innerHTML = '';
        
        // Add empty state message
        const emptyState = document.createElement('div');
        emptyState.className = 'empty-state';
        emptyState.textContent = 'No tasks yet';
        todoList.appendChild(emptyState);
        
        // Reset the title to default
        updateTitleWithCurrentDate();
        
        showStatus('List cleared', 'success');
    }
}

        /* ========== FILE MANAGEMENT ========== */
        async function selectFolder() {
            try {
                if (window.showDirectoryPicker) {
                    directoryHandle = await window.showDirectoryPicker();
                    updateFolderDisplay();
                    checkForSavedFiles();
                    showStatus('Folder selected', 'success');
                } else {
                    // Fallback for mobile devices
                    showStatus('On mobile, please use Export/Import instead', 'info');
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    showStatus('Error selecting folder', 'error');
                    console.error(error);
                }
            }
        }

        function updateFolderDisplay() {
            if (directoryHandle && directoryHandle.name) {
                document.getElementById('current-folder').textContent = `Current folder: ${directoryHandle.name}`;
            } else {
                document.getElementById('current-folder').textContent = 'No folder selected (use Export/Import on mobile)';
            }
        }

async function saveToFile() {
    try {
        const title = document.getElementById('title').value.trim();
        if (!title) {
            showStatus('Please enter a title for your list', 'warning');
            return;
        }
        
        // Check if we're on mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (isMobile || !window.showDirectoryPicker) {
            // Mobile fallback - use export instead
            showExportModal();
            return;
        }
        
        if (!directoryHandle) {
            showStatus('Please select a folder first', 'warning');
            return await selectFolder();
        }
        
const items = [];
document.querySelectorAll('#todo-list .todo-item').forEach(li => {
    items.push({
        text: li.querySelector('.item-text').textContent,
        completed: li.classList.contains('completed'),
        isSection: li.classList.contains('section-break'),
        note: li.dataset.note || '',
        indent: parseInt(li.dataset.indent || "0") // Include indent level
    });
});
        
        const todoData = {
            title: title,
            items: items,
            timestamp: new Date().toISOString()
        };
        
        const fileName = `${title.replace(/[^a-z0-9]/gi, '_')}.todo`;
        const fileHandle = await directoryHandle.getFileHandle(fileName, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(JSON.stringify(todoData, null, 2));
        await writable.close();
        
        fileHandles[fileName] = fileHandle;
        
        showStatus(`Saved as "${fileName}"`, 'success');
        checkForSavedFiles();
    } catch (error) {
        showStatus(`Error saving: ${error.message}`, 'error');
        console.error(error);
    }
}

async function loadFromFile(fileName) {
    try {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (isMobile || !window.showDirectoryPicker) {
            showImportModal();
            return;
        }
        
        if (!directoryHandle) {
            showStatus('Please select a folder first', 'warning');
            return await selectFolder();
        }
        
        let fileHandle;
        if (fileName) {
            fileHandle = await directoryHandle.getFileHandle(fileName);
        } else {
            fileHandle = await window.showOpenFilePicker({
                types: [{
                    description: 'To-Do Files',
                    accept: { 'application/json': ['.todo', '.json'] }
                }],
                excludeAcceptAllOption: true
            });
            fileHandle = fileHandle[0];
        }
        
        const file = await fileHandle.getFile();
        const contents = await file.text();
        const todoData = JSON.parse(contents);
        
        document.getElementById('title').value = todoData.title;
        
        const todoList = document.getElementById('todo-list');
        todoList.innerHTML = '';
        
        if (todoData.items.length === 0) {
            todoList.innerHTML = '<div class="empty-state">No tasks yet</div>';
        } else {
            todoData.items.forEach(item => {
                // Clamp indent level between 0-5
                const indentLevel = Math.min(Math.max(item.indent || 0, 0), 5);
                
                if (item.isSection) {
                    const li = document.createElement('li');
                    li.className = 'todo-item section-break';
                    li.draggable = true;
                    li.dataset.indent = indentLevel;
                    li.style.marginLeft = `${indentLevel * 1.5}rem`;
                    li.innerHTML = `
                        <span class="drag-handle">‚ò∞</span>
                        <span class="item-text">${item.text}</span>
                        <textarea class="item-edit" rows="1">${item.text}</textarea>
                        <button class="delete-btn">√ó</button>
                    `;
                    todoList.appendChild(li);
                } else {
                    const li = document.createElement('li');
                    li.className = 'todo-item';
                    li.draggable = true;
                    if (item.completed) li.classList.add('completed');
                    li.dataset.indent = indentLevel;
                    li.style.marginLeft = `${indentLevel * 1.5}rem`;
                    
                    const note = item.note || '';
                    li.innerHTML = `
                        <span class="drag-handle">‚ò∞</span>
                        <input type="checkbox" class="item-checkbox" ${item.completed ? 'checked' : ''}>
                        <span class="note-indicator" style="${note.trim() ? 'opacity:1' : 'opacity:0'}" data-note="${note}"></span>
                        <span class="item-text">${item.text}</span>
                        <textarea class="item-edit" rows="1">${item.text}</textarea>
                        <button class="note-btn ${note.trim() ? 'has-note' : ''}" onclick="showNoteModal(this)">üìù</button>
                        <span class="note-preview" style="display: none;">${note}</span>
                        <button class="indent-btn" onclick="indentItem(this)">‚á•</button>
                        <button class="outdent-btn" onclick="outdentItem(this)">‚á§</button>
                        <button class="delete-btn">√ó</button>
                    `;
                    
                    if (note.trim()) {
                        li.dataset.note = note;
                        const noteBtn = li.querySelector('.note-btn');
                        const notePreview = li.querySelector('.note-preview');
                        
                        if (noteBtn) {
                            noteBtn.addEventListener('mouseenter', () => {
                                notePreview.textContent = note;
                                notePreview.style.display = 'block';
                            });
                            noteBtn.addEventListener('mouseleave', () => {
                                notePreview.style.display = 'none';
                            });
                        }
                    }
                    
                    todoList.appendChild(li);
                }
            });
        }
        
        showStatus(`Loaded "${file.name}"`, 'success');
    } catch (error) {
        if (error.name !== 'AbortError') {
            showStatus(`Error loading: ${error.message}`, 'error');
            console.error(error);
        }
    }
  ensureToggleButtons();
}

        async function deleteFile(fileName, event) {
            event.stopPropagation();
            try {
                if (!directoryHandle) {
                    showStatus('Please select a folder first', 'warning');
                    return await selectFolder();
                }
                
                if (confirm(`Delete "${fileName}"?`)) {
                    await directoryHandle.removeEntry(fileName);
                    showStatus(`Deleted "${fileName}"`, 'warning');
                    checkForSavedFiles();
                }
            } catch (error) {
                showStatus(`Error deleting: ${error.message}`, 'error');
                console.error(error);
            }
        }

        async function checkForSavedFiles() {
            try {
                const container = document.getElementById('saved-files-container');
                
                if (!directoryHandle) {
                    container.innerHTML = '<div class="empty-state">Select a folder to view saved lists (use Export/Import on mobile)</div>';
                    return;
                }
                
                const files = [];
                for await (const entry of directoryHandle.values()) {
                    if (entry.kind === 'file' && (entry.name.endsWith('.todo') || entry.name.endsWith('.json'))) {
                        const file = await entry.getFile();
                        files.push({
                            name: entry.name,
                            date: new Date(file.lastModified)
                        });
                    }
                }
                
                displaySavedFiles(files.sort((a, b) => b.date - a.date));
            } catch (error) {
                console.error(error);
                document.getElementById('saved-files-container').innerHTML = 
                    '<div class="empty-state">Error loading saved files</div>';
            }
        }



function displaySavedFiles(files) {
    const container = document.getElementById('saved-files-container');
    
    if (files.length === 0) {
        container.innerHTML = '<div class="empty-state">No saved lists found</div>';
        return;
    }
    
    container.innerHTML = '';
    
    files.forEach(file => {
        const fileElement = document.createElement('div');
        fileElement.className = 'saved-file';
fileElement.innerHTML = `
    <div class="saved-file-name" data-filename="${file.name}" title="${file.name}">
        ${file.name.replace('.todo', '').replace('.json', '')}
    </div>
    <div class="saved-file-date">${file.date.toLocaleDateString()}</div>
    <button class="delete-saved-btn" onclick="deleteFile('${file.name.replace(/'/g, "\\'")}', event)">√ó</button>
`;
        
        // Modified click handler to properly load the file
fileElement.addEventListener('click', async (e) => {
    if (e.target.classList.contains('delete-saved-btn')) return;

    try {
        await loadFromFile(file.name);
        window.scrollTo({ top: 0, behavior: 'smooth' }); // <-- scroll to top after loading
    } catch (error) {
        showStatus(`Error loading file: ${error.message}`, 'error');
        console.error(error);
    }
});

        
        container.appendChild(fileElement);
    });
}

function showStatus(message, type = 'info') {
    const statusEl = document.getElementById('status');
    statusEl.textContent = message;
    statusEl.style.display = 'block';
    statusEl.className = '';
    
    // Remove any existing fade-out class
    statusEl.classList.remove('fade-out');
    
    // Set status type colors
    switch(type) {
        case 'success':
            statusEl.style.backgroundColor = '#e6ffed';
            statusEl.style.color = '#22863a';
            statusEl.style.borderLeft = '4px solid #22863a';
            break;
        case 'warning':
            statusEl.style.backgroundColor = '#fff8e6';
            statusEl.style.color = '#d46b08';
            statusEl.style.borderLeft = '4px solid #d46b08';
            break;
        case 'error':
            statusEl.style.backgroundColor = '#ffe6e6';
            statusEl.style.color = '#cb2431';
            statusEl.style.borderLeft = '4px solid #cb2431';
            break;
        default:
            statusEl.style.backgroundColor = '#e8f4fd';
            statusEl.style.color = '#0366d6';
            statusEl.style.borderLeft = '4px solid #0366d6';
    }
    
    // Auto-hide after delay
    setTimeout(() => {
        statusEl.classList.add('fade-out');
        setTimeout(() => {
            statusEl.style.display = 'none';
        }, 300);
    }, 5000); // Show for 3 seconds
}

        // Add keyboard event for mobile
document.getElementById('new-item').addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if (e.ctrlKey || e.metaKey) { // Add to top with Ctrl+Enter or Cmd+Enter
            addItemToTop();
        } else { // Regular Enter adds to bottom
            addItem();
        }
    }
});


function printToPDF() {
    const printContainer = document.createElement('div');
    printContainer.className = 'print-container';
    
    // Title and date
    const title = document.getElementById('title').value || 'To-Do List';
    const titleElement = document.createElement('h1');
    titleElement.className = 'print-title';
    titleElement.style.textAlign = 'left';
    titleElement.textContent = title;
    printContainer.appendChild(titleElement);
    
    const dateElement = document.createElement('div');
    dateElement.className = 'print-date';
    dateElement.style.textAlign = 'left';
    dateElement.textContent = 'Generated: ' + new Date().toLocaleString();
    printContainer.appendChild(dateElement);
    
    // Create list container
    const listContainer = document.createElement('div');
    listContainer.className = 'print-list';
    
    // Add all items with indentation
    const todoItems = document.querySelectorAll('#todo-list .todo-item');
    todoItems.forEach(item => {
        const indent = parseInt(item.dataset.indent || "0");
        
        if (item.classList.contains('section-break')) {
            const sectionDiv = document.createElement('h2');
            sectionDiv.className = 'print-section';
            sectionDiv.style.textAlign = 'left';
            sectionDiv.style.marginLeft = `${indent * 20}px`;
            sectionDiv.textContent = item.querySelector('.item-text').textContent;
            listContainer.appendChild(sectionDiv);
        } else {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'print-item';
            itemDiv.style.marginLeft = `${indent * 20}px`;
            
            // FIXED CHECKBOX - Using a single character
            const checkbox = document.createElement('span');
            checkbox.className = 'print-checkbox';
            // Using simple Unicode characters for checkboxes
            checkbox.textContent = item.querySelector('.item-checkbox').checked ? 
                '‚òë' : '‚òê';  // Using ballot box with X and empty ballot box
            checkbox.style.fontSize = '16pt';
            checkbox.style.marginRight = '10px';
            itemDiv.appendChild(checkbox);
            
            const textSpan = document.createElement('span');
            textSpan.className = 'print-item-text';
            textSpan.textContent = item.querySelector('.item-text').textContent;
            
            if (item.classList.contains('completed')) {
                textSpan.style.textDecoration = 'line-through';
                textSpan.style.color = '#777';
            }
            
            itemDiv.appendChild(textSpan);
            listContainer.appendChild(itemDiv);
        }
    });
    
    printContainer.appendChild(listContainer);
    
    // Updated print styles
    const style = document.createElement('style');
    style.textContent = `
        @media print {
            body * {
                visibility: hidden;
            }
            .print-container, .print-container * {
                visibility: visible;
            }
            .print-container {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                padding: 20px;
                text-align: left !important;
            }
            .print-title {
                font-size: 24pt;
                margin-bottom: 10px;
                color: #000;
                border-bottom: 2px solid #000;
                padding-bottom: 5px;
            }
            .print-date {
                font-size: 10pt;
                margin-bottom: 20px;
                color: #555;
            }
            .print-section {
                font-size: 16pt;
                margin: 15px 0 5px 0;
                color: #333;
                border-bottom: 1px solid #ddd;
                padding-bottom: 3px;
            }
            .print-item {
                display: flex;
                align-items: center;
                margin: 8px 0;
                font-size: 12pt;
                page-break-inside: avoid;
            }
            .print-checkbox {
                display: inline-block;
                margin-right: 10px;
                font-size: 16pt;
                width: auto !important;
                height: auto !important;
                border: none !important;
            }
            .print-item-text {
                flex: 1;
            }
            .print-item.completed .print-item-text {
                text-decoration: line-through;
                color: #777;
            }
        }
    `;
    printContainer.appendChild(style);
    
    // Print and clean up
    document.body.appendChild(printContainer);
    window.print();
    setTimeout(() => {
        document.body.removeChild(printContainer);
    }, 1000);
}

function printToPDFWithNotes() {
    // Create print container
    const printContainer = document.createElement('div');
    printContainer.className = 'print-container';
    
    // Add title (left-aligned)
    const title = document.getElementById('title').value || 'To-Do List';
    const titleElement = document.createElement('h1');
    titleElement.className = 'print-title';
    titleElement.style.textAlign = 'left';
    titleElement.textContent = title;
    printContainer.appendChild(titleElement);
    
    // Add date (left-aligned)
    const dateElement = document.createElement('div');
    dateElement.className = 'print-date';
    dateElement.style.textAlign = 'left';
    dateElement.textContent = 'Generated: ' + new Date().toLocaleString();
    printContainer.appendChild(dateElement);
    
    // Create list container
    const listContainer = document.createElement('div');
    listContainer.className = 'print-list';
    
    // Add all items with indentation
    const todoItems = document.querySelectorAll('#todo-list .todo-item');
    todoItems.forEach(item => {
        const indent = parseInt(item.dataset.indent || "0");
        
        if (item.classList.contains('section-break')) {
            // Add section header
            const sectionDiv = document.createElement('h2');
            sectionDiv.className = 'print-section';
            sectionDiv.style.textAlign = 'left';
            sectionDiv.style.marginLeft = `${indent * 20}px`;
            sectionDiv.textContent = item.querySelector('.item-text').textContent;
            listContainer.appendChild(sectionDiv);
        } else {
            // Create item container
            const itemDiv = document.createElement('div');
            itemDiv.className = 'print-item';
            itemDiv.style.marginLeft = `${indent * 20}px`;
            
            // Add SINGLE checkbox (fixed version)
            const checkbox = document.createElement('span');
            checkbox.className = 'print-checkbox';
            // Using simple Unicode checkboxes
            checkbox.textContent = item.querySelector('.item-checkbox').checked ? 
                '‚òë' : '‚òê'; // Filled vs empty checkbox
            checkbox.style.fontSize = '16pt';
            checkbox.style.marginRight = '10px';
            itemDiv.appendChild(checkbox);
            
            // Add item text
            const textSpan = document.createElement('span');
            textSpan.className = 'print-item-text';
            textSpan.textContent = item.querySelector('.item-text').textContent;
            
            if (item.classList.contains('completed')) {
                textSpan.style.textDecoration = 'line-through';
                textSpan.style.color = '#777';
            }
            
            itemDiv.appendChild(textSpan);
            listContainer.appendChild(itemDiv);
            
            // Add note if it exists (indented one level more)
            const note = item.dataset.note;
            if (note && note.trim()) {
                const noteDiv = document.createElement('div');
                noteDiv.className = 'print-note';
                noteDiv.style.marginLeft = `${(indent + 1) * 20}px`;
                noteDiv.style.marginTop = '5px';
                noteDiv.style.fontStyle = 'italic';
                noteDiv.style.color = '#555';
                noteDiv.style.fontSize = '0.9em';
                noteDiv.textContent = `Note: ${note}`;
                noteDiv.style.whiteSpace = "pre-wrap";
                listContainer.appendChild(noteDiv);
            }
        }
    });
    
    printContainer.appendChild(listContainer);
    
    // Apply print styles
    const style = document.createElement('style');
    style.textContent = `
        @media print {
            body * {
                visibility: hidden;
            }
            .print-container, .print-container * {
                visibility: visible;
            }
            .print-container {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                padding: 20px;
                background: white;
            }
            .print-title {
                font-size: 24pt;
                margin-bottom: 10px;
                color: #000;
                border-bottom: 2px solid #000;
                padding-bottom: 5px;
                text-align: left !important;
            }
            .print-date {
                font-size: 10pt;
                margin-bottom: 20px;
                color: #555;
                text-align: left !important;
            }
            .print-section {
                font-size: 16pt;
                margin: 15px 0 5px 0;
                color: #333;
                border-bottom: 1px solid #ddd;
                padding-bottom: 3px;
                text-align: left !important;
            }
            .print-item {
                display: flex;
                align-items: center;
                margin: 8px 0;
                font-size: 12pt;
                page-break-inside: avoid;
            }
            .print-checkbox {
                display: inline-block;
                margin-right: 10px;
                font-size: 16pt;
                width: auto !important;
                height: auto !important;
                border: none !important;
            }
            .print-item-text {
                flex: 1;
            }
            .print-note {
                page-break-inside: avoid;
            }
        }
    `;
    printContainer.appendChild(style);
    
    // Print
    document.body.appendChild(printContainer);
    window.print();
    
    // Clean up
    setTimeout(() => {
        document.body.removeChild(printContainer);
    }, 1000);
}

function popoutListWithNotes() {
    const title = document.getElementById('title').value || 'To-Do List';
    let html = `
        <!DOCTYPE html>
        <html>
        <head>
            <title>${title}</title>
            <style>
                body {
                    font-family: Arial, sans-serif;
                    line-height: 1.2;
                    padding: 20px;
                    max-width: 800px;
                    margin: 0 auto;
                    color: #333;
                }
                h1 {
                    color: #4361ee;
                    border-bottom: 2px solid #4361ee;
                    padding-bottom: 3px;
                    margin-bottom: 10px;
                    font-size: 1.5em;
                }
                .date {
                    color: #666;
                    margin-bottom: 10px;
                    font-size: 0.9em;
                }
                .section {
                    color: #7209b7;
                    margin: 25px 0 10px 0;
                    border-bottom: 1px solid #ddd;
                    padding-bottom: 1px;
                    font-size: 1.2em;
                }
                .task {
                    margin: 3px 0;
                    padding: 0px;
                    display: flex;
                    align-items: flex-start;
                }
                .task.completed {
                    text-decoration: line-through;
                    color: #777;
                    font-size: 1.0em;
                }
                .checkbox {
                    margin-right: 10px;
                    font-size: 1.8em;
                }
                .task-content {
                    flex: 1;
                }
                .note {
                    margin-top: 8px;
                    padding: 5px;
                    background: #e8f4fd;
                    border-left: 3px solid #4895ef;
                    font-style: italic;
                    border-radius: 0 4px 4px 0;
                }
            </style>
        </head>
        <body>
            <h1>${title}</h1>
            <div class="date">Generated: ${new Date().toLocaleString()}</div>
    `;

    // Add all items with indentation
    document.querySelectorAll('#todo-list .todo-item').forEach(item => {
        const text = item.querySelector('.item-text').textContent;
        const indent = parseInt(item.dataset.indent || "0");
        
        if (item.classList.contains('section-break')) {
            html += `<h2 class="section" style="margin-left: ${indent * 20}px">${text}</h2>`;
        } else {
            const completed = item.classList.contains('completed') ? 'completed' : '';
            const checked = item.querySelector('.item-checkbox').checked ? '‚úì' : '‚óª';
            const note = item.dataset.note || '';
            
            html += `
                <div class="task ${completed}" style="margin-left: ${indent * 20}px">
                    <div class="checkbox">${checked}</div>
                    <div class="task-content">
                        ${text}
                        ${note ? `<div class="note" style="white-space:pre-wrap;">${note.replace(/\n/g, '<br>')}</div>` : ''}
                    </div>
                </div>
            `;
        }
    });

    html += `
<div id="dynalist-help-modal" class="modal">
  <h3>How to Connect to Dynalist</h3>
  <div class="modal-content">
    <div class="help-section">
      <h4>1. Get your API Key</h4>
      <p>Go to <a href="https://dynalist.io/developer" target="_blank">Dynalist Developer Page</a><br>
      Copy your personal API key.</p>
    </div>
    <div class="help-section">
      <h4>2. Get your Document ID</h4>
      <p>Open the Dynalist document you want to export into.<br>
      The URL looks like: <code>https://dynalist.io/d/AbCdEfGhIjKlMnOpQrStUv</code><br>
      ‚Üí The part after <code>/d/</code> is your Document ID.</p>
    </div>
    <div class="help-section">
      <h4>3. Paste into this app</h4>
      <p>When exporting, you‚Äôll be prompted to enter your API key and Document ID.<br>
      They are stored locally in your browser (never shared).</p>
    </div>
    <p>‚úÖ After setup, click <b>Export to Dynalist</b> and your tasks will appear in Dynalist.</p>
    <div class="modal-actions">
      <button class="secondary" onclick="hideDynalistHelp()">Close</button>
    </div>
  </div>
</div>

</body></html>`;

    const popout = window.open('', '_blank', 'width=800,height=600,scrollbars=yes,resizable=yes');
    popout.document.write(html);
    popout.document.close();
    popout.focus();
}

function popoutListWithNotes2() {
    const printContainer = document.createElement('div');
    printContainer.className = 'print-container';
    
    const title = document.getElementById('title').value || 'To-Do List';
    const titleElement = document.createElement('h1');
    titleElement.className = 'print-title';
    titleElement.textContent = title;
    printContainer.appendChild(titleElement);
    
    const dateElement = document.createElement('div');
    dateElement.className = 'print-date';
    dateElement.textContent = 'Generated: ' + new Date().toLocaleString();
    printContainer.appendChild(dateElement);
    
    const todoItems = document.querySelectorAll('#todo-list .todo-item');
    todoItems.forEach(item => {
        const indent = parseInt(item.dataset.indent || "0");
        
        if (item.classList.contains('section-break')) {
            const sectionDiv = document.createElement('h2');
            sectionDiv.className = 'print-section';
            sectionDiv.style.marginLeft = `${indent * 20}px`;
            sectionDiv.textContent = item.querySelector('.item-text').textContent;
            printContainer.appendChild(sectionDiv);
        } else {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'print-item';
            itemDiv.style.marginLeft = `${indent * 20}px`;
            
            const checkbox = document.createElement('span');
            checkbox.className = 'print-checkbox';
            checkbox.innerHTML = item.querySelector('.item-checkbox').checked ? 
                '‚úì' : '‚óª';
            itemDiv.appendChild(checkbox);
            
            const textSpan = document.createElement('span');
            textSpan.className = 'print-item-text';
            textSpan.textContent = item.querySelector('.item-text').textContent;
            if (item.classList.contains('completed')) {
                textSpan.style.textDecoration = 'line-through';
                textSpan.style.color = '#777';
            }
            itemDiv.appendChild(textSpan);
            printContainer.appendChild(itemDiv);
            
            // Add note if it exists
            const note = item.dataset.note;
            if (note && note.trim()) {
                const noteDiv = document.createElement('div');
                noteDiv.className = 'print-note';
                noteDiv.style.marginLeft = `${(indent + 1) * 20}px`;
                noteDiv.style.marginTop = '5px';
                noteDiv.style.fontStyle = 'italic';
                noteDiv.style.color = '#555';
                noteDiv.style.fontSize = '0.9em';
                noteDiv.textContent = `Note: ${note}`;
                noteDiv.style.whiteSpace = "pre-wrap";
                printContainer.appendChild(noteDiv);
            }
        }
    });
    
    const popout = window.open('', '_blank', 'width=800,height=600,scrollbars=yes');
    popout.document.write(printContainer.innerHTML);
    popout.document.close();
}

function popoutCleanView() {
    const originalContainer = document.querySelector('.container');
    const cleanContainer = originalContainer.cloneNode(true);
    
    // Get the current title
    const currentTitle = document.getElementById('title').value || 'To-Do List';
    
    // Remove interactive elements (preserve all styling)
    const elementsToRemove = [
        '.input-group',
        '.controls',
        '.saved-lists',
        '.footer',
        '#status',
        '#current-folder',
        '#title',
        'h1'
    ];
    
    elementsToRemove.forEach(selector => {
        const elements = cleanContainer.querySelectorAll(selector);
        elements.forEach(el => el.remove());
    });

    // First pass: identify which items are hidden due to section toggles
    const hiddenItems = new Set();
    const allOriginalItems = Array.from(document.querySelectorAll('#todo-list .todo-item'));
    
    allOriginalItems.forEach((section, index) => {
        if (!section.classList.contains('section-break')) return;
        
        const toggleBtn = section.querySelector('.toggle-btn');
        if (toggleBtn && toggleBtn.textContent === '‚ñ∏') { // Section is collapsed
            const sectionIndent = parseInt(section.dataset.indent || "0");
            
            for (let i = index + 1; i < allOriginalItems.length; i++) {
                const item = allOriginalItems[i];
                const itemIndent = parseInt(item.dataset.indent || "0");
                
                // Stop when we hit another section or item with same/lower indent
                if (item.classList.contains('section-break') && itemIndent <= sectionIndent) break;
                if (!item.classList.contains('section-break') && itemIndent <= sectionIndent) break;
                
                // Mark this item as hidden
                hiddenItems.add(item);
            }
        }
    });

    // Process the todo items in the clean container
    const cleanItems = cleanContainer.querySelectorAll('#todo-list .todo-item');
    cleanItems.forEach(item => {
        // Find matching original item by text content
        const itemText = item.querySelector('.item-text')?.textContent;
        const originalItem = allOriginalItems.find(original => 
            original.querySelector('.item-text')?.textContent === itemText
        );
        
        // Remove if this item is hidden
        if (hiddenItems.has(originalItem)) {
            item.remove();
            return;
        }

        // Remove interactive elements (preserve all styling classes)
        item.querySelectorAll('.item-edit, .delete-btn, .note-btn, .indent-btn, .outdent-btn, .drag-handle, .toggle-btn').forEach(el => el.remove());
        
        // Add bullet point before checkbox (preserve existing styling)
        if (!item.classList.contains('section-break')) {
            const bullet = document.createElement('span');
            bullet.className = 'bullet-point';
            bullet.textContent = '‚Ä¢';
            bullet.style.marginRight = '1px';// Reduced from 6px to 4px
            bullet.style.color = '#4361ee'; // Primary color blue
            
            const checkbox = item.querySelector('.item-checkbox');
            if (checkbox) {
                // Adjust checkbox margin if needed
                checkbox.style.marginRight = '1px';  // Added if not present
                item.insertBefore(bullet, checkbox);
            } else {
                const dragHandle = item.querySelector('.drag-handle');
                item.insertBefore(bullet, dragHandle ? dragHandle.nextSibling : item.firstChild);
            }
            // Adjust the item-text margin if it exists
            const itemText = item.querySelector('.item-text');
            if (itemText) {
                itemText.style.marginLeft = '0';  // Remove any existing left margin
                itemText.style.paddingLeft = '0';  // Remove any existing padding
            }
        }
        
        // Only add note if the item isn't hidden and has a note
        const note = originalItem?.dataset.note;
        if (note && note.trim()) {
            const noteDisplay = document.createElement('div');
            noteDisplay.className = 'clean-view-note';
            noteDisplay.textContent = note;
            noteDisplay.style.whiteSpace = 'pre-wrap';
            noteDisplay.style.margin = '2px 0 0 38px'; // Increased from 28px to 38px
            noteDisplay.style.padding = '4px 6px';  
            noteDisplay.style.background = '#f8f9fa';
            noteDisplay.style.borderLeft = '3px solid #4895ef'; // Light blue accent color
            noteDisplay.style.fontSize = '0.85em';
            noteDisplay.style.color = '#555';
            noteDisplay.style.borderRadius = '0 4px 4px 0';
            noteDisplay.style.lineHeight = '1.4';
            
            const container = document.createElement('div');
            container.className = 'todo-item-container';
            
            const indentLevel = parseInt(item.dataset.indent || "0");
            const indentPx = indentLevel * 20;
            
            container.appendChild(item.cloneNode(true));
            noteDisplay.style.marginLeft = `${indentPx + 38}px`; // Increased from 28px to 38p
            container.appendChild(noteDisplay);
            
            item.replaceWith(container);
        }
        
        // Preserve existing item styling
        item.style.transform = '';
        item.style.boxShadow = 'none';
    });

    // Generate the popout window with all original styles preserved
    const popout = window.open('', '_blank', 'width=600,height=800,scrollbars=yes');
    
    popout.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
            <title>${currentTitle}</title>
            <style>
                body {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                    margin: 0;
                    padding: 10px;
                    background: #f5f7fa;
                }
                .container {
                    background: white;
                    border-radius: 8px;
                    padding: 10px;
                    max-width: 800px;
                    margin: 0 auto;
                }
                h1 {
                    color: #4361ee; /* Primary blue color */
                    text-align: center;
                    margin-bottom: 10px;
                    font-size: 1.5rem;
                }
                .todo-item {
                    padding: 4px 4px 4px 8px;
                    margin-bottom: 3px;
                    border-radius: 4px;
                    background: white;
                    border-left: 3px solid transparent;
                    display: flex;
                    align-items: center;
                    gap: 6px;
                }
                .bullet-point {
                    margin-right: 6px;
                    color: #4361ee; /* Primary blue color */
                }
                .todo-item-container {
                    margin-bottom: 6px;
                }
                .todo-item input[type="checkbox"] {
                    margin: 0;
                    flex-shrink: 0;
                    width: 16px;
                    height: 16px;
                }
                .todo-item .item-text {
                    margin: 0;
                    padding: 0;
                    flex-grow: 1;
                }
                .todo-item.completed {
                    opacity: 0.7;
                }
                .todo-item.completed .item-text {
                    text-decoration: line-through;
                    color: #777;
                }
                .todo-item.section-break {
                    font-weight: bold;
                    color: #7209b7; /* Pink/purple section color */
                    background: rgba(114, 9, 183, 0.1);
                    border-left: 3px solid #7209b7; /* Pink/purple section color */
                    margin-top: 8px;
                    margin-bottom: 4px;
                    display: block;
                    padding: 6px 8px;
                }
                .clean-view-note {
                    margin: 2px 0 0 28px;
                    padding: 4px 6px;
                    background: #f8f9fa;
                    border-left: 3px solid #4895ef; /* Light blue accent color */
                    font-size: 0.85em;
                    color: #555;
                    border-radius: 0 4px 4px 0;
                    line-height: 1.4;
                }
                [data-indent="1"] { margin-left: 1.2rem; }
                [data-indent="2"] { margin-left: 2.4rem; }
                [data-indent="3"] { margin-left: 3.6rem; }
                [data-indent="4"] { margin-left: 4.8rem; }
                [data-indent="5"] { margin-left: 6.0rem; }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>${currentTitle}</h1>
                ${cleanContainer.innerHTML}
            </div>
        
<div id="dynalist-help-modal" class="modal">
  <h3>How to Connect to Dynalist</h3>
  <div class="modal-content">
    <div class="help-section">
      <h4>1. Get your API Key</h4>
      <p>Go to <a href="https://dynalist.io/developer" target="_blank">Dynalist Developer Page</a><br>
      Copy your personal API key.</p>
    </div>
    <div class="help-section">
      <h4>2. Get your Document ID</h4>
      <p>Open the Dynalist document you want to export into.<br>
      The URL looks like: <code>https://dynalist.io/d/AbCdEfGhIjKlMnOpQrStUv</code><br>
      ‚Üí The part after <code>/d/</code> is your Document ID.</p>
    </div>
    <div class="help-section">
      <h4>3. Paste into this app</h4>
      <p>When exporting, you‚Äôll be prompted to enter your API key and Document ID.<br>
      They are stored locally in your browser (never shared).</p>
    </div>
    <p>‚úÖ After setup, click <b>Export to Dynalist</b> and your tasks will appear in Dynalist.</p>
    <div class="modal-actions">
      <button class="secondary" onclick="hideDynalistHelp()">Close</button>
    </div>
  </div>
</div>

</body>
        </html>
    `);
    popout.document.close();
    
    return popout;
}

function popoutCleanView2() {
    const originalContainer = document.querySelector('.container');
    const cleanContainer = originalContainer.cloneNode(true);
    
    // Get the current title
    const currentTitle = document.getElementById('title').value || 'To-Do List';
    
    // Format current date (YYYY-MM-DD Day)
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const today = new Date();
    const formattedDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')} ${days[today.getDay()]}`;
    
    // Remove interactive elements
    const elementsToRemove = [
        '.input-group',
        '.controls',
        '.saved-lists',
        '.footer',
        '#status',
        '#current-folder',
        '#title',
        'h1'
    ];
    
    elementsToRemove.forEach(selector => {
        const elements = cleanContainer.querySelectorAll(selector);
        elements.forEach(el => el.remove());
    });

    // First pass: identify which items are hidden due to section toggles
    const hiddenItems = new Set();
    const allItems = Array.from(document.querySelectorAll('.todo-item'));
    
    allItems.forEach((section, index) => {
        if (!section.classList.contains('section-break')) return;
        
        const toggleBtn = section.querySelector('.toggle-btn');
        if (toggleBtn && toggleBtn.textContent === '‚ñ∏') { // Section is collapsed
            const sectionIndent = parseInt(section.dataset.indent || "0");
            
            for (let i = index + 1; i < allItems.length; i++) {
                const item = allItems[i];
                const itemIndent = parseInt(item.dataset.indent || "0");
                
                // Stop when we hit another section or item with same/lower indent
                if (item.classList.contains('section-break') && itemIndent <= sectionIndent) break;
                if (!item.classList.contains('section-break') && itemIndent <= sectionIndent) break;
                
                // Mark this item as hidden
                hiddenItems.add(item);
            }
        }
    });

    // Second pass: remove all hidden items and their notes
    cleanContainer.querySelectorAll('.todo-item').forEach(item => {
        const originalItem = allItems.find(original => 
            original.querySelector('.item-text')?.textContent === 
            item.querySelector('.item-text')?.textContent
        );
        
        if (hiddenItems.has(originalItem)) {
            item.remove();
            return;
        }

        // Remove interactive elements and any existing bullet points
        item.querySelectorAll('.item-edit, .delete-btn, .note-btn, .indent-btn, .outdent-btn, .drag-handle, .toggle-btn, .bullet-point').forEach(el => el.remove());
        
        // Only add note if the item isn't hidden
        const note = originalItem?.dataset.note;
        if (note && note.trim()) {
            const noteDisplay = document.createElement('div');
            noteDisplay.className = 'clean-view-note';
            noteDisplay.textContent = note;
            noteDisplay.style.whiteSpace = 'pre-wrap';
            
            const container = document.createElement('div');
            container.className = 'todo-item-container';
            
            const indentLevel = parseInt(item.dataset.indent || "0");
            const indentPx = indentLevel * 20;
            
            container.appendChild(item.cloneNode(true));
            noteDisplay.style.marginLeft = `${indentPx + 28}px`;
            container.appendChild(noteDisplay);
            
            item.replaceWith(container);
        }
        
        item.style.transform = '';
        item.style.boxShadow = 'none';
    });

    const popout = window.open('', '_blank', 'width=600,height=800,scrollbars=yes');
    
    popout.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
            <title>${currentTitle}</title>
            <style>
                body {
                    font-family: Arial, sans-serif;
                    line-height: 1.2;
                    padding: 20px;
                    max-width: 800px;
                    margin: 0 auto;
                    color: #333;
                }
                h1 {
                    color: #4361ee;
                    border-bottom: 2px solid #4361ee;
                    padding-bottom: 3px;
                    margin-bottom: 10px;
                    font-size: 1.5em;
                }
                .current-date {
                    color: #666;
                    margin-bottom: 15px;
                    font-size: 0.9em;
                    font-style: italic;
                }
                .section {
                    color: #7209b7;
                    margin: 25px 0 10px 0;
                    border-bottom: 1px solid #ddd;
                    padding-bottom: 1px;
                    font-size: 1.2em;
                }
                .task {
                    margin: 3px 0;
                    padding: 0px;
                    display: flex;
                    align-items: flex-start;
                }
                .task.completed {
                    text-decoration: line-through;
                    color: #777;
                    font-size: 1.0em;
                }
                .checkbox {
                    margin-right: 10px;
                    font-size: 1.8em;
                }
                .task-content {
                    flex: 1;
                }
                .clean-view-note {
                    margin-top: 5px;
                    padding: 5px;
                    background: #f5f5f5;
                    border-left: 2px solid #4895ef;
                    font-size: 0.85em;
                    color: #555;
                    line-height: 1.4;
                    border-radius: 0 4px 4px 0;
                }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>${currentTitle}</h1>
                <div class="current-date">${formattedDate}</div>
                ${cleanContainer.innerHTML}
            </div>
        
<div id="dynalist-help-modal" class="modal">
  <h3>How to Connect to Dynalist</h3>
  <div class="modal-content">
    <div class="help-section">
      <h4>1. Get your API Key</h4>
      <p>Go to <a href="https://dynalist.io/developer" target="_blank">Dynalist Developer Page</a><br>
      Copy your personal API key.</p>
    </div>
    <div class="help-section">
      <h4>2. Get your Document ID</h4>
      <p>Open the Dynalist document you want to export into.<br>
      The URL looks like: <code>https://dynalist.io/d/AbCdEfGhIjKlMnOpQrStUv</code><br>
      ‚Üí The part after <code>/d/</code> is your Document ID.</p>
    </div>
    <div class="help-section">
      <h4>3. Paste into this app</h4>
      <p>When exporting, you‚Äôll be prompted to enter your API key and Document ID.<br>
      They are stored locally in your browser (never shared).</p>
    </div>
    <p>‚úÖ After setup, click <b>Export to Dynalist</b> and your tasks will appear in Dynalist.</p>
    <div class="modal-actions">
      <button class="secondary" onclick="hideDynalistHelp()">Close</button>
    </div>
  </div>
</div>

</body>
        </html>
    `);
    popout.document.close();
    
    return popout;
}

function toggleCleanView() {
    if (cleanViewWindow && !cleanViewWindow.closed) {
        cleanViewWindow.close();
        cleanViewWindow = null;
        showStatus('Clean view closed', 'info');
    } else {
        cleanViewWindow = popoutCleanView();
        showStatus('Clean view opened (with notes)', 'success');
        
        const checkWindow = setInterval(() => {
            if (cleanViewWindow.closed) {
                clearInterval(checkWindow);
                cleanViewWindow = null;
            }
        }, 500);
    }
}

function printVisibleList() {
    // Create a clone of the visible container
    const originalContainer = document.querySelector('.container');
    const printContainer = originalContainer.cloneNode(true);
    
    // Remove all elements we don't want to print
    const elementsToRemove = [
        '.input-group',
        '.controls',
        '.saved-lists',
        '.footer',
        '#status',
        '#current-folder'
    ];
    
    elementsToRemove.forEach(selector => {
        const elements = printContainer.querySelectorAll(selector);
        elements.forEach(el => el.remove());
    });

    // Clean up individual todo items (remove edit inputs and delete buttons)
    printContainer.querySelectorAll('.todo-item').forEach(item => {
        item.querySelectorAll('.item-edit, .delete-btn').forEach(el => el.remove());
        item.style.transform = ''; // Remove any transform effects
        item.style.boxShadow = 'none'; // Remove shadows for cleaner print
    });

    // Apply print-specific styles
    const style = document.createElement('style');
    style.textContent = `
        @media print {
            body * {
                visibility: hidden;
            }
            .print-visible, .print-visible * {
                visibility: visible;
            }
            .print-visible {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                padding: 20px;
                background: white;
            }
            .container {
                box-shadow: none !important;
                border: none !important;
            }
            @page {
                size: auto;
                margin: 15mm;
            }
        }
    `;
    
    // Add classes and prepare for printing
    printContainer.classList.add('print-visible');
    document.body.appendChild(printContainer);
    document.head.appendChild(style);
    
    // Print and clean up
    window.print();
    setTimeout(() => {
        document.body.removeChild(printContainer);
        document.head.removeChild(style);
    }, 1000);
}

function shareList() {
    try {
        const title = document.getElementById('title').value || 'My To-Do List';
        let text = `${title}\n\n`;
        
        // Format all items with indentation
        document.querySelectorAll('#todo-list .todo-item').forEach(item => {
            const indent = parseInt(item.dataset.indent || "0");
            const indentSpaces = ' '.repeat(indent * 2); // 2 spaces per indent level
            const itemText = item.querySelector('.item-text').textContent;
            
            if (item.classList.contains('section-break')) {
                text += `\n${indentSpaces}${itemText}\n${indentSpaces}${'-'.repeat(itemText.length)}\n`;
            } else {
                const checked = item.querySelector('.item-checkbox')?.checked ? '[‚úì]' : '[ ]';
                text += `${indentSpaces}${checked} ${itemText}\n`;
                
                // Add note if it exists
                const note = item.dataset.note;
                if (note && note.trim()) {
                    text += `${indentSpaces}  Note: ${note}\n`;
                }
            }
        });
        
        // Try to use the Web Share API if available
        if (navigator.share) {
            navigator.share({
                title: title,
                text: text
            }).catch(() => {
                showShareModal(title, text);
            });
        } else {
            showShareModal(title, text);
        }
    } catch (error) {
        console.error('Sharing error:', error);
        showStatus('Error preparing share options. Try exporting instead.', 'error');
    }
}

function showShareModal(title, text) {
    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'overlay';
    overlay.id = 'share-overlay';
    overlay.style.display = 'block';
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.id = 'share-modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <h3>Share "${title}"</h3>
        <div class="modal-content">
            <div class="share-options">
                <div class="share-option" id="email-share">
                    <span>‚úâÔ∏è</span> Email (Gmail)
                </div>
                <div class="share-option" id="copy-share">
                    <span>üìã</span> Copy Text
                </div>
                <div class="share-option" id="download-share">
                    <span>üì•</span> Download
                </div>
            </div>
            <textarea id="share-text" readonly>${text}</textarea>
            <div class="modal-actions">
                <button class="secondary" id="close-share">Close</button>
            </div>
        </div>
    `;
    
    // Add to page
    document.body.appendChild(overlay);
    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';
    
    // Add event listeners
document.getElementById('email-share').addEventListener('click', (e) => {
    e.preventDefault();
    
    // Get the list title
    const title = document.getElementById('title').value || 'My To-Do List';
    
    // Build HTML content for email body
    let htmlContent = `
        <div style="font-family: Arial, sans-serif; line-height: 1.5; color: #333; max-width: 600px;">
            <h2 style="color: #4361ee; border-bottom: 2px solid #4361ee; padding-bottom: 5px; margin-bottom: 15px;">
                ${title}
            </h2>
            <ul style="padding-left: 20px; list-style-type: none; margin: 0;">
    `;

    // Add all todo items to email body
    document.querySelectorAll('#todo-list .todo-item').forEach(item => {
        const itemText = item.querySelector('.item-text').textContent;
        if (item.classList.contains('section-break')) {
            htmlContent += `
                </ul>
                <h3 style="color: #7209b7; margin-top: 15px; border-bottom: 1px solid #ddd; padding-bottom: 3px;">
                    ${itemText}
                </h3>
                <ul style="padding-left: 20px; list-style-type: none; margin: 0;">
            `;
        } else {
            const checked = item.querySelector('.item-checkbox')?.checked ? '‚úì' : '‚óª';
            const textColor = item.classList.contains('completed') ? '#777' : '#333';
            const textDecoration = item.classList.contains('completed') ? 'line-through' : 'none';
            
            htmlContent += `
                <li style="margin-bottom: 8px; position: relative; padding-left: 25px; color: ${textColor}; text-decoration: ${textDecoration}">
                    <span style="position: absolute; left: 0; color: #4361ee;">${checked}</span>
                    ${itemText}
                </li>
            `;
        }
    });

    htmlContent += `
            </ul>
            <p style="margin-top: 20px; font-size: 0.9em; color: #777;">
                Shared from Smart To-Do List
            </p>
        </div>
    `;

    // Create plain text version as fallback
    const plainText = `${title}\n${'='.repeat(title.length)}\n\n` + 
        Array.from(document.querySelectorAll('#todo-list .todo-item')).map(item => {
            const text = item.querySelector('.item-text').textContent;
            if (item.classList.contains('section-break')) {
                return `\n${text}\n${'-'.repeat(text.length)}\n`;
            } else {
                const checked = item.querySelector('.item-checkbox')?.checked ? '[‚úì]' : '[ ]';
                return `${checked} ${text}`;
            }
        }).join('\n') + 
        `\n\nShared from Smart To-Do List`;

    // Special handling for Chrome browser
    if (navigator.userAgent.indexOf('Chrome') > -1) {
        // Chrome-specific Gmail handling
        const gmailUrl = new URL('https://mail.google.com/mail/u/0/?view=cm&fs=1');
        gmailUrl.searchParams.set('su', title);
        gmailUrl.searchParams.set('body', plainText);
        
        // Open in new window with specific size
        window.open(gmailUrl.toString(), '_blank', 'width=800,height=600');
    } 
    // For other browsers, use standard mailto
    else {
        window.location.href = `mailto:?subject=${encodeURIComponent(title)}&body=${encodeURIComponent(plainText)}`;
    }
    
    hideShareModal();
});
    
    document.getElementById('copy-share').addEventListener('click', () => {
        const textarea = document.getElementById('share-text');
        textarea.select();
        document.execCommand('copy');
        showStatus('Copied to clipboard!', 'success');
        hideShareModal();
    });
    
    document.getElementById('download-share').addEventListener('click', () => {
        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${title.replace(/[^a-z0-9]/gi, '_')}.txt`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            hideShareModal();
        }, 100);
    });
    
    document.getElementById('close-share').addEventListener('click', hideShareModal);
    overlay.addEventListener('click', hideShareModal);
}

function hideShareModal() {
    const modal = document.getElementById('share-modal');
    const overlay = document.getElementById('share-overlay');
    if (modal) modal.remove();
    if (overlay) overlay.remove();
    document.body.style.overflow = '';
}

//Help modal
function showHelpModal() {
    showModal('help');
}

// Update the existing hideModal function to handle help modal
function hideModal(type) {
    document.getElementById(`${type}-overlay`).style.display = 'none';
    document.getElementById(`${type}-modal`).style.display = 'none';
    document.body.style.overflow = '';
}

// Template data (could also load from external files)
const templates = {
     office: {
        title: "Office starting",
        items: [
            { isSection: true, text: "Prep" },
            { text: "Timer start", completed: false },
            { text: "Self-Chat of officestarting", completed: false },
            { text: "Tea-making", completed: false },
            { isSection: true, text: "Review" },
            { text: "Review what I have done", completed: false },
            { text: "Preview what's coming", completed: false },
            { isSection: true, text: "Goal-setting" },
            { text: "Project checking", completed: false },
            { text: "Teaching", completed: false },
            { text: "Social", completed: false },
            { text: "Lab", completed: false },
            { isSection: true, text: "Info-update" },
            { text: "Line", completed: false },
            { text: "Email", completed: false },
            
        ]
    },
    basic: {
        title: "Daily Tasks",
        items: [
            { text: "Morning routine", completed: false },
            { text: "Check emails", completed: false },
            { text: "Exercise", completed: false },
            { isSection: true, text: "Evening" },
            { text: "Plan tomorrow", completed: false }
        ]
    },
    shopping: {
        title: "Shopping List",
        items: [
            { isSection: true, text: "Groceries" },
            { text: "Milk", completed: false },
            { text: "Eggs", completed: false },
            { text: "Bread", completed: false }
        ]
    },
    work: {
        title: "Work Projects",
        items: [
            { isSection: true, text: "Urgent" },
            { text: "Finish report", completed: false },
            { isSection: true, text: "Ongoing" },
            { text: "Client meeting", completed: false }
        ]
    }
};

function showTemplateImport() {
    showModal('template');
}

function loadTemplate(templateName) {
    const template = templates[templateName];
    if (!template) return;
    
    // Clear current list if not empty
    if (document.querySelectorAll('#todo-list .todo-item').length > 0) {
        if (!confirm("Replace current list with template?")) return;
    }
    
    // Set title
    document.getElementById('title').value = template.title;
    
    // Clear and add items
    const todoList = document.getElementById('todo-list');
    todoList.innerHTML = '';
    
    template.items.forEach(item => {
        if (item.isSection) {
            const li = document.createElement('li');
            li.className = 'todo-item section-break';
            li.innerHTML = `
                <span class="drag-handle">‚ò∞</span>
                <span class="item-text">${item.text}</span>
                <textarea class="item-edit" rows="1">${item.text}</textarea>
                <button class="delete-btn">√ó</button>
            `;
            todoList.appendChild(li);
        } else {
            const li = document.createElement('li');
            li.className = 'todo-item';
            li.innerHTML = `
                <span class="drag-handle">‚ò∞</span>
                <input type="checkbox" class="item-checkbox" ${item.completed ? 'checked' : ''}>
                <span class="item-text">${item.text}</span>
                <textarea class="item-edit" rows="1">${item.text}</textarea>
     <button class="note-btn" onclick="showNoteModal(this)">üìù</button>

                <button class="delete-btn">√ó</button>
            `;
            if (item.completed) li.classList.add('completed');
            todoList.appendChild(li);
        }
    });
    
    hideModal('template');
    showStatus(`Loaded "${templateName}" template`, 'success');

ensureToggleButtons();
}

function uploadTemplate() {
    const fileInput = document.getElementById('template-file');
    const file = fileInput.files[0];
    
    if (!file) {
        showStatus('No file selected', 'warning');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const template = JSON.parse(e.target.result);
            loadTemplateData(template);
        } catch (error) {
            showStatus('Invalid template file', 'error');
            console.error(error);
        }
    };
    reader.readAsText(file);
}

function loadTemplateData(templateData) {
    // Same implementation as loadTemplate()
    // but using the uploaded templateData instead
}

function setDefaultTemplate(templateName) {
    localStorage.setItem('defaultTemplate', templateName);
    showStatus(`"${templateName}" set as default template`, 'success');
}

function clearDefaultTemplate() {
    localStorage.removeItem('defaultTemplate');
    showStatus('Default template cleared', 'success');
}

let currentNoteItem = null;

function showNoteModal(button) {
    const item = button.closest('.todo-item');
    const itemText = item.querySelector('.item-text').textContent;
    
    currentNoteItem = item;
    
    // Get existing note if any
    const existingNote = item.dataset.note || '';
    
    document.getElementById('note-item-title').textContent = itemText;
    document.getElementById('note-content').value = existingNote;
    
    showModal('note');
    setupNoteTextarea(); // Add this line
    document.getElementById('note-content').focus();
}

function saveNote() {
    if (!currentNoteItem) return;
    
    const noteContent = document.getElementById('note-content').value;
    currentNoteItem.dataset.note = noteContent;
    
    // Update visual indicators
    const noteBtn = currentNoteItem.querySelector('.note-btn');
    const noteIndicator = currentNoteItem.querySelector('.note-indicator');
    const notePreview = currentNoteItem.querySelector('.note-preview');
    
    if (noteContent.trim()) {
        noteBtn.classList.add('has-note');
        if (noteIndicator) {
            noteIndicator.style.opacity = '1';
            noteIndicator.setAttribute('data-note', noteContent);
        }
        if (notePreview) {
            notePreview.textContent = noteContent;
        }
        showStatus('Note saved', 'success');
    } else {
        noteBtn.classList.remove('has-note');
        if (noteIndicator) noteIndicator.style.opacity = '0';
        if (notePreview) notePreview.textContent = '';
    }
    
    hideModal('note');
    currentNoteItem = null;
    
    saveTodo(); // This will check autoSaveEnabled internally
}

// Scroll to Saved Files
function scrollToSaved() {
    const savedSection = document.querySelector('.saved-lists');
    if (savedSection) {
        savedSection.scrollIntoView({ behavior: 'smooth' });
    }
}

// Scroll back to top
function scrollToTop() {
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Show/hide scroll-up button near bottom
window.addEventListener('scroll', () => {
    const scrollUpBtn = document.getElementById('scroll-up-btn');
    const showAt = document.body.scrollHeight - window.innerHeight - 300;
    if (window.scrollY > showAt) {
        scrollUpBtn.style.display = 'block';
    } else {
        scrollUpBtn.style.display = 'none';
    }
});

// Fade away after 5 seconds of inactivity
let fadeTimeout;
const scrollDownBtn = document.getElementById('scroll-down-btn');

function resetFadeTimer() {
    if (!scrollDownBtn) return;

    scrollDownBtn.classList.remove('fade-out');
    clearTimeout(fadeTimeout);
    fadeTimeout = setTimeout(() => {
        scrollDownBtn.classList.add('fade-out');
    }, 5000);
}

// Scroll button visibility control
window.addEventListener('scroll', () => {
    const scrollUpBtn = document.getElementById('scroll-up-btn');
    const scrollDownBtn = document.getElementById('scroll-down-btn');
    const scrollPosition = window.scrollY;
    const windowHeight = window.innerHeight;
    const documentHeight = document.body.scrollHeight;
    
    // Show up button when scrolled down
    scrollUpBtn.style.display = scrollPosition > 100 ? 'flex' : 'none';
    
    // Show down button when not at bottom (with 100px buffer)
    scrollDownBtn.style.display = (scrollPosition + windowHeight < documentHeight - 100) ? 'flex' : 'none';
});

// Initialize buttons on load
window.addEventListener('DOMContentLoaded', () => {
    const scrollDownBtn = document.getElementById('scroll-down-btn');
    // Show down button initially if content is scrollable
    if (document.body.scrollHeight > window.innerHeight) {
        scrollDownBtn.style.display = 'flex';
    }
    
    // Reset fade timer (if you're using it)
    resetFadeTimer();
});

// Reset timer on mousemove
document.addEventListener('mousemove', resetFadeTimer);

// Initialize on load
window.addEventListener('DOMContentLoaded', () => {
    resetFadeTimer(); // start fade timer immediately
});

// Toggle note preview on tap for mobile
document.addEventListener('click', function (e) {
    const isNoteBtn = e.target.classList.contains('note-btn');
    const preview = isNoteBtn ? e.target.nextElementSibling : null;

    if (preview && preview.classList.contains('note-preview')) {
        // Toggle visibility
        const isVisible = preview.style.display === 'block';
        // First, hide all open previews
        document.querySelectorAll('.note-preview').forEach(p => p.style.display = 'none');
        // Then, toggle this one
        preview.style.display = isVisible ? 'none' : 'block';
        e.stopPropagation();
    } else {
        // Hide all previews if clicking anywhere else
        document.querySelectorAll('.note-preview').forEach(p => p.style.display = 'none');
    }
});

function indentItem(btn) {
    const item = btn.closest('.todo-item');
    if (item.classList.contains('section-break')) return;
    
    const currentIndent = parseInt(item.dataset.indent || "0");
    if (currentIndent < 5) {
        item.dataset.indent = currentIndent + 1;
        item.style.marginLeft = `${(currentIndent + 1) * 1.5}rem`;
    }
    
    // Always ensure toggle buttons are updated after indenting
    ensureToggleButtons();
}

function outdentItem(btn) {
    const item = btn.closest('.todo-item');
    if (item.classList.contains('section-break')) return;
    
    const currentIndent = parseInt(item.dataset.indent || "0");
    if (currentIndent > 0) {
        item.dataset.indent = currentIndent - 1;
        item.style.marginLeft = `${(currentIndent - 1) * 1.5}rem`;
    }

    // Always ensure toggle buttons are updated after outdenting
    ensureToggleButtons();
}

function insertBulletPoint() {
    const textarea = document.getElementById('note-content');
    const currentPos = textarea.selectionStart;
    const currentValue = textarea.value;
    
    // Get current line
    const textBeforeCursor = currentValue.substring(0, currentPos);
    const lineStart = textBeforeCursor.lastIndexOf('\n') + 1;
    const currentLine = textBeforeCursor.substring(lineStart);
    
    // Count existing indentation
    const indentMatch = currentLine.match(/^(\s*)/);
    const indent = indentMatch ? indentMatch[1] : '';
    
    // Insert bullet point with same indentation
    textarea.value = currentValue.substring(0, currentPos) + 
                    (indent ? '\n' + indent : '') + '‚Ä¢ ' + 
                    currentValue.substring(currentPos);
    
    // Move cursor after the bullet point
    const newPos = currentPos + (indent ? indent.length + 3 : 2);
    textarea.selectionStart = newPos;
    textarea.selectionEnd = newPos;
    
    // Keep focus on the textarea
    textarea.focus();
}

function insertNumberedPoint() {
    const textarea = document.getElementById('note-content');
    const currentPos = textarea.selectionStart;
    const currentValue = textarea.value;
    
    // Get current line
    const textBeforeCursor = currentValue.substring(0, currentPos);
    const lineStart = textBeforeCursor.lastIndexOf('\n') + 1;
    const currentLine = textBeforeCursor.substring(lineStart);
    
    // Count existing indentation
    const indentMatch = currentLine.match(/^(\s*)/);
    const indent = indentMatch ? indentMatch[1] : '';
    
    // Find the next available number in the current indentation level
    let nextNumber = 1;
    const lines = currentValue.split('\n');
    const currentIndentLevel = indent.length;
    
    for (const line of lines) {
        const lineIndentMatch = line.match(/^(\s*)/);
        const lineIndent = lineIndentMatch ? lineIndentMatch[1] : '';
        
        // Only consider lines with same indentation level
        if (lineIndent.length === currentIndentLevel) {
            const numberedMatch = line.trim().match(/^(\d+)\./);
            if (numberedMatch) {
                const lineNum = parseInt(numberedMatch[1]);
                if (lineNum >= nextNumber) {
                    nextNumber = lineNum + 1;
                }
            }
        }
    }
    
    // Insert at cursor position with same indentation
    textarea.value = currentValue.substring(0, currentPos) + 
                    (indent ? '\n' + indent : '') + 
                    `${nextNumber}. ` + 
                    currentValue.substring(currentPos);
    
    // Position cursor after the number
    const newPos = currentPos + (indent ? indent.length : 0) + `${nextNumber}. `.length + (indent ? 1 : 0);
    textarea.selectionStart = newPos;
    textarea.selectionEnd = newPos;
    textarea.focus();
}

// Setup auto-formatting for Enter key
function setupNoteTextarea() {
    const textarea = document.getElementById('note-content');
    
    textarea.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            const currentPos = this.selectionStart;
            const textBeforeCursor = this.value.substring(0, currentPos);
            const lineStart = textBeforeCursor.lastIndexOf('\n') + 1;
            const currentLine = textBeforeCursor.substring(lineStart).trim();
            
            // Handle bullet points
            if (currentLine.startsWith('‚Ä¢')) {
                e.preventDefault();
                this.value = textBeforeCursor + '\n‚Ä¢ ' + this.value.substring(currentPos);
                this.selectionStart = currentPos + 3;
                this.selectionEnd = currentPos + 3;
            }
            // Handle numbered lists
            else if (/^\d+\./.test(currentLine)) {
                e.preventDefault();
                const numMatch = currentLine.match(/^(\d+)\./);
                if (numMatch) {
                    const num = parseInt(numMatch[1]);
                    this.value = textBeforeCursor + `\n${num + 1}. ` + this.value.substring(currentPos);
                    this.selectionStart = currentPos + `${num + 1}. `.length + 1;
                    this.selectionEnd = this.selectionStart;
                }
            }
            // Handle when Enter is pressed on an empty bullet point
            else if (/^\s*‚Ä¢\s*$/.test(currentLine)) {
                e.preventDefault();
                // Remove the bullet point if it's empty
                this.value = textBeforeCursor.substring(0, lineStart - 1) + this.value.substring(currentPos);
                this.selectionStart = lineStart - 1;
                this.selectionEnd = lineStart - 1;
            }
            // Handle when Enter is pressed on an empty numbered point
            else if (/^\s*\d+\.\s*$/.test(currentLine)) {
                e.preventDefault();
                // Remove the numbered point if it's empty
                this.value = textBeforeCursor.substring(0, lineStart - 1) + this.value.substring(currentPos);
                this.selectionStart = lineStart - 1;
                this.selectionEnd = lineStart - 1;
            }
        }
        // Handle Tab key for indentation
        else if (e.key === 'Tab') {
            e.preventDefault();
            const start = this.selectionStart;
            const end = this.selectionEnd;
            
            if (e.shiftKey) {
                // Shift+Tab - outdent
                if (this.value.substring(start - 2, start) === '  ') {
                    this.value = this.value.substring(0, start - 2) + this.value.substring(start);
                    this.selectionStart = start - 2;
                    this.selectionEnd = end - 2;
                }
            } else {
                // Tab - indent
                this.value = this.value.substring(0, start) + '  ' + this.value.substring(start);
                this.selectionStart = start + 2;
                this.selectionEnd = end + 2;
            }
        }
    });
}

function toggleSectionItems(button) {
    const section = button.closest('.todo-item');
    const allItems = Array.from(document.querySelectorAll('.todo-item'));
    const startIndex = allItems.indexOf(section);
    const sectionIndent = parseInt(section.dataset.indent || "0");

    let toggle = button.textContent === '‚ñæ'; // currently expanded
    button.textContent = toggle ? '‚ñ∏' : '‚ñæ'; // toggle icon

    for (let i = startIndex + 1; i < allItems.length; i++) {
        const item = allItems[i];
        const itemIndent = parseInt(item.dataset.indent || "0");

        // Stop at next section or same/higher indent
        if (item.classList.contains('section-break') || itemIndent <= sectionIndent) break;

        item.style.display = toggle ? 'none' : '';
    }
}

function ensureToggleButtons() {
    const sections = document.querySelectorAll('.todo-item.section-break');
    sections.forEach(section => {
        const hasItems = hasIndentedItemsBelow(section);
        let toggle = section.querySelector('.toggle-btn');
        
        if (hasItems) {
            if (!toggle) {
                toggle = document.createElement('button');
                toggle.className = 'toggle-btn';
                toggle.textContent = '‚ñæ';
                toggle.onclick = function() {
                    toggleSectionItems(toggle);
                };
                
                const drag = section.querySelector('.drag-handle');
                section.insertBefore(toggle, drag.nextSibling);
            }
            toggle.style.display = '';
        } else {
            if (toggle) {
                toggle.style.display = 'none';
            }
        }
    });
}

function hasIndentedItemsBelow(section) {
    const allItems = Array.from(document.querySelectorAll('.todo-item'));
    const startIndex = allItems.indexOf(section);
    const sectionIndent = parseInt(section.dataset.indent || "0");
    
    for (let i = startIndex + 1; i < allItems.length; i++) {
        const item = allItems[i];
        const itemIndent = parseInt(item.dataset.indent || "0");
        
        // If we hit another section with same or lower indent, stop
        if (item.classList.contains('section-break') && itemIndent <= sectionIndent) {
            break;
        }
        
        // If we find any item with higher indent than the section, return true
        if (itemIndent > sectionIndent) {
            return true;
        }
        
        // If we hit an item with same or lower indent that's not a section, stop
        if (itemIndent <= sectionIndent && !item.classList.contains('section-break')) {
            break;
        }
    }
    
    return false;
}

function toggleAllSections() {
    // Get all section toggle buttons
    const toggleButtons = document.querySelectorAll('.toggle-btn');
    
    // Check if any sections are currently expanded (default to true if no buttons exist)
    let anyExpanded = toggleButtons.length === 0 || 
                     Array.from(toggleButtons).some(btn => btn.textContent === '‚ñæ');
    
    // Toggle all sections
    toggleButtons.forEach(btn => {
        if (btn.style.display !== 'none') {  // Only toggle visible buttons
            if (anyExpanded) {
                // Collapse all
                if (btn.textContent === '‚ñæ') {
                    toggleSectionItems(btn);
                }
            } else {
                // Expand all
                if (btn.textContent === '‚ñ∏') {
                    toggleSectionItems(btn);
                }
            }
        }
    });
    
    // Update button text based on new state
    const toggleAllBtn = document.querySelector('button[onclick="toggleAllSections()"]');
    if (toggleAllBtn) {
        toggleAllBtn.textContent = anyExpanded ? '‚ñ∂ Expand All' : 'üîΩ Collapse All';
    }
}

function addItemToTop() {
    const input = document.getElementById('new-item');
    const text = input.value.trim();
    if (text === '') {
        showStatus('Please enter a task', 'warning');
        return;
    }

    const li = document.createElement('li');
    li.className = 'todo-item';
    li.draggable = true;
    li.dataset.indent = "0";
    li.style.marginLeft = '0rem';

    li.innerHTML = `
        <span class="drag-handle">‚ò∞</span>
        <input type="checkbox" class="item-checkbox">
        <span class="note-indicator" style="opacity:0"></span>
        <span class="item-text">${text}</span>
        <textarea class="item-edit" rows="1">${text}</textarea>
        <button class="note-btn" onclick="showNoteModal(this)">üìù</button>
        <button class="indent-btn" onclick="indentItem(this)">‚á•</button>
        <button class="outdent-btn" onclick="outdentItem(this)">‚á§</button>
        <button class="delete-btn">√ó</button>
    `;

    // Initialize note preview functionality
    const noteBtn = li.querySelector('.note-btn');
    const notePreview = li.querySelector('.note-preview');
    
    noteBtn.addEventListener('mouseenter', () => {
        if (li.dataset.note) {
            notePreview.textContent = li.dataset.note;
            notePreview.style.display = 'block';
        }
    });
    
    noteBtn.addEventListener('mouseleave', () => {
        notePreview.style.display = 'none';
    });

    // Remove empty state if present
    const todoList = document.getElementById('todo-list');
    if (todoList.querySelector('.empty-state')) {
        todoList.innerHTML = '';
    }

    // Insert at the top of the list instead of appending
    if (todoList.firstChild) {
        todoList.insertBefore(li, todoList.firstChild);
    } else {
        todoList.appendChild(li);
    }
    
    input.value = '';
    input.focus();
    showStatus('Task added to top', 'success');
    
    ensureToggleButtons();
    
    saveTodo(); // This will check autoSaveEnabled internally
}

// Auto-save variables
let autoSaveEnabled = false;
let autoSaveTimeout = null;

function toggleAutoSave() {
    autoSaveEnabled = !autoSaveEnabled;
    const btn = document.getElementById('auto-save-btn');
    
    if (autoSaveEnabled) {
        btn.textContent = 'üîÅ Auto-Save: On';
        btn.classList.add('active');
        showStatus('Auto-save enabled', 'success');
        // Save immediately when enabling
        saveTodo();
    } else {
        btn.textContent = 'üîÅ Auto-Save: Off';
        btn.classList.remove('active');
        showStatus('Auto-save disabled', 'warning');
        // Clear any pending save
        if (autoSaveTimeout) {
            clearTimeout(autoSaveTimeout);
            autoSaveTimeout = null;
        }
    }
    
    // Save preference to localStorage
    localStorage.setItem('autoSaveEnabled', autoSaveEnabled);
}

function saveTodo() {
    if (autoSaveEnabled) {
        // Debounce the save to prevent too many rapid saves
        if (autoSaveTimeout) {
            clearTimeout(autoSaveTimeout);
        }
        autoSaveTimeout = setTimeout(() => {
            saveToFile();
            autoSaveTimeout = null;
        }, 1000); // 1 second delay
    }
}

function initAutoSave() {
    const savedSetting = localStorage.getItem('autoSaveEnabled');
    if (savedSetting === 'true') {
        autoSaveEnabled = true;
        const btn = document.getElementById('auto-save-btn');
        if (btn) {
            btn.textContent = 'üîÅ Auto-Save: On';
            btn.classList.add('active');
        }
    }
}

// Call this in DOMContentLoaded
document.addEventListener('DOMContentLoaded', function() {
    initAutoSave();
    // ... rest of your initialization code
});

// Add these new functions for the sync functionality
function showSyncModal() {
    // Generate the sync link
    generateSyncLink();
    // Show the modal
    showModal('sync');
}

function generateSyncLink() {
    // Get the current to-do list data
    const todoData = {
        title: document.getElementById('title').value,
        items: []
    };
    
    // Get all the to-do items
    document.querySelectorAll('#todo-list .todo-item').forEach(item => {
        const itemData = {
            text: item.querySelector('.item-text').textContent,
            completed: item.classList.contains('completed'),
            isSection: item.classList.contains('section-break'),
            note: item.dataset.note || '',
            indent: parseInt(item.dataset.indent || "0")
        };
        todoData.items.push(itemData);
    });
    
    // Convert to JSON and encode for URL
    const jsonData = JSON.stringify(todoData);
    const encodedData = encodeURIComponent(jsonData);
    
    // Create the URL with the data as a parameter
    const currentUrl = window.location.href.split('?')[0];
    const syncUrl = `${currentUrl}?data=${encodedData}`;
    
    // Display the URL in the input field
    document.getElementById('sync-link').value = syncUrl;
}

function copySyncLink() {
    const syncLinkInput = document.getElementById('sync-link');
    syncLinkInput.select();
    
    try {
        navigator.clipboard.writeText(syncLinkInput.value).then(() => {
            showStatus('Sync link copied to clipboard!', 'success');
        }).catch(err => {
            // Fallback for browsers that don't support clipboard API
            document.execCommand('copy');
            showStatus('Sync link copied to clipboard!', 'success');
        });
    } catch (error) {
        // Fallback for older browsers
        document.execCommand('copy');
        showStatus('Sync link copied to clipboard!', 'success');
    }
}

function checkUrlForData() {
    const urlParams = new URLSearchParams(window.location.search);
    const todoData = urlParams.get('data');
    
    if (todoData) {
        showLoadModal();
        window.todoDataToLoad = todoData;
    }
}

function showLoadModal() {
    showModal('load');
}

function hideLoadModal() {
    hideModal('load');
    // Clean URL without reloading the page
    const url = new URL(window.location);
    url.searchParams.delete('data');
    window.history.replaceState({}, '', url);
}

function loadFromLink() {
    if (window.todoDataToLoad) {
        try {
            const data = decodeURIComponent(window.todoDataToLoad);
            const todoData = JSON.parse(data);
            
            // Set the title
            document.getElementById('title').value = todoData.title || '';
            
            // Clear the current list
            const todoList = document.getElementById('todo-list');
            todoList.innerHTML = '';
            
            // Add the new items
            if (todoData.items && todoData.items.length > 0) {
                todoData.items.forEach(item => {
                    if (item.isSection) {
                        // Add section
                        const li = document.createElement('li');
                        li.className = 'todo-item section-break';
                        li.draggable = true;
                        li.dataset.indent = item.indent || 0;
                        li.style.marginLeft = `${(item.indent || 0) * 1.5}rem`;
                        li.innerHTML = `
                            <span class="drag-handle">‚ò∞</span>
                            <button class="toggle-btn" onclick="toggleSectionItems(this)">‚ñæ</button>
                            <span class="item-text">${item.text}</span>
                            <textarea class="item-edit" rows="1">${item.text}</textarea>
                            <button class="delete-btn">√ó</button>
                        `;
                        todoList.appendChild(li);
                    } else {
                        // Add regular item
                        const li = document.createElement('li');
                        li.className = 'todo-item';
                        li.draggable = true;
                        if (item.completed) li.classList.add('completed');
                        li.dataset.indent = item.indent || 0;
                        li.style.marginLeft = `${(item.indent || 0) * 1.5}rem`;
                        
                        if (item.note) {
                            li.dataset.note = item.note;
                        }
                        
                        li.innerHTML = `
                            <span class="drag-handle">‚ò∞</span>
                            <input type="checkbox" class="item-checkbox" ${item.completed ? 'checked' : ''}>
                            <span class="note-indicator" style="${item.note && item.note.trim() ? 'opacity:1' : 'opacity:0'}" data-note="${item.note || ''}"></span>
                            <span class="item-text">${item.text}</span>
                            <textarea class="item-edit" rows="1">${item.text}</textarea>
                            <button class="note-btn ${item.note ? 'has-note' : ''}" onclick="showNoteModal(this)">üìù</button>
                            <span class="note-preview" style="display: none;">${item.note || ''}</span>
                            <button class="indent-btn" onclick="indentItem(this)">‚á•</button>
                            <button class="outdent-btn" onclick="outdentItem(this)">‚á§</button>
                            <button class="delete-btn">√ó</button>
                        `;
                        todoList.appendChild(li);
                    }
                });
                
                showStatus('Tasks loaded from link!', 'success');
            } else {
                todoList.innerHTML = '<div class="empty-state">No tasks yet</div>';
            }
            
            hideLoadModal();
            ensureToggleButtons();
        } catch (error) {
            console.error('Error loading from link:', error);
            showStatus('Error loading tasks from the link', 'error');
            hideLoadModal();
        }
    }
}

    
async function ensureDynalistCredentials() {
    if (!dynalistApiKey) {
        dynalistApiKey = prompt("Enter your Dynalist API Key:");
        if (dynalistApiKey) localStorage.setItem("dynalistApiKey", dynalistApiKey);
    }
    if (!dynalistDocId) {
        dynalistDocId = prompt("Enter your Dynalist Document ID:");
        if (dynalistDocId) localStorage.setItem("dynalistDocId", dynalistDocId);
    }
    return dynalistApiKey && dynalistDocId;
}

async function exportAllToDynalist() {
    if (!(await ensureDynalistCredentials())) {
        showStatus("Dynalist credentials missing", "error");
        return;
    }

    // Collect items with their indent level
    const items = Array.from(document.querySelectorAll("#todo-list .todo-item"))
        .map(el => ({
            text: el.querySelector(".item-text").textContent.trim(),
            indent: parseInt(el.getAttribute("data-indent") || "0", 10)
        }))
        .filter(obj => obj.text.length > 0);

    if (items.length === 0) {
        showStatus("No items to export", "error");
        return;
    }

    try {
        // Read doc to get existing root structure (for index placement)
        const readRes = await fetch("https://dynalist.io/api/v1/doc/read", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ token: dynalistApiKey, file_id: dynalistDocId })
        });
        const readData = await readRes.json();
        if (readData._code !== "Ok") {
            showStatus("Error: " + readData._msg, "error");
            return;
        }

        const rootNodes = readData.nodes.filter(n => n.parent === "root");
        let rootIndex = rootNodes.length;

        // Track parent IDs by indent level
        let parentStack = { 0: "root" };

        // Insert items sequentially
        for (const item of items) {
            const parentId = parentStack[item.indent] || "root";

            const editRes = await fetch("https://dynalist.io/api/v1/doc/edit", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    token: dynalistApiKey,
                    file_id: dynalistDocId,
                    changes: [{
                        action: "insert",
                        parent_id: parentId,
                        content: item.text,
                        index: parentId === "root" ? rootIndex++ : -1
                    }]
                })
            });
            const editData = await editRes.json();
            if (editData._code === "Ok" && editData.new_node_ids && editData.new_node_ids.length > 0) {
                // Save this node as the parent for deeper indents
                const newNodeId = editData.new_node_ids[0];
                parentStack[item.indent + 1] = newNodeId;
            } else if (editData._code !== "Ok") {
                console.error("Failed to insert item:", item.text, editData);
            }
        }

        showStatus("Exported " + items.length + " items (with hierarchy) to Dynalist", "success");
        window.open(
            `https://dynalist.io/d/${dynalistDocId}`,
            "dynalistPopup",
            "width=1000,height=700,resizable=yes,scrollbars=yes,toolbar=no,location=no,status=no,menubar=no"
        );
    } catch (err) {
        console.error(err);
        showStatus("Error exporting to Dynalist", "error");
    }
}

function showDynalistHelp() { document.getElementById('dynalist-help-modal').style.display = 'block'; }
function hideDynalistHelp() { document.getElementById('dynalist-help-modal').style.display = 'none'; }
</script>

<!-- Help Modal -->
<div class="overlay" id="help-overlay"></div>
<div class="modal" id="help-modal">
    <h3>How to Use This To-Do List</h3>
    <div class="modal-content">
        <div class="help-section">
            <h4>Basic Usage</h4>
            <ul>
                <li><strong>Add Task:</strong> Type in the input box and click "Add" or press Enter</li>
                <li><strong>Complete Task:</strong> Click the checkbox</li>
                <li><strong>Edit Task:</strong> Click directly on the task text</li>
                <li><strong>Delete Task:</strong> Click the √ó button</li>
                <li><strong>Reorder:</strong> Drag tasks up/down using the ‚ò∞ handle</li>
            </ul>
        </div>
        
        <div class="help-section">
            <h4>Advanced Features</h4>
            <ul>
                <li><strong>Sections:</strong> Use "Add Section" to group tasks</li>
                <li><strong>Save/Load:</strong> Save lists to your device or browser storage</li>
                <li><strong>Import/Export:</strong> Share lists between devices</li>
                <li><strong>Print/PDF:</strong> Create printer-friendly versions</li>
            </ul>
        </div>
        
        <div class="modal-actions">
            <button class="secondary" onclick="hideModal('help')">Got It!</button>
        </div>
    </div>
</div>

<!-- Template Import Modal -->
<div class="overlay" id="template-overlay"></div>
<div class="modal" id="template-modal">
    <h3>Template Options</h3>
    <div class="modal-content">
        <div class="template-options">
            <div class="template-option" onclick="loadTemplate('basic')">
                <h4>Basic Tasks</h4>
                <p>Daily to-do list template</p>
            </div>
            <div class="template-option" onclick="loadTemplate('shopping')">
                <h4>Shopping List</h4>
                <p>Grocery store template</p>
            </div>
            <div class="template-option" onclick="loadTemplate('work')">
                <h4>Work Projects</h4>
                <p>Task management template</p>
            </div>
            <div class="template-option" onclick="loadTemplate('office')">
                <h4>Office Tasks</h4>
                <p>Office starting routine</p>
            </div>
        </div>
        
        <div class="default-template-section" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
            <h4>Default Template Settings</h4>
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin: 0.5rem 0;">
                <button onclick="setDefaultTemplate('basic')">Set Basic Default</button>
                <button onclick="setDefaultTemplate('office')">Set Office Default</button>
                <button onclick="clearDefaultTemplate()" class="secondary">Clear Default</button>
            </div>
        </div>
        
        <div class="file-upload" style="margin-top: 1.5rem;">
            <label for="template-file">Upload your own template (.todo or .json):</label>
            <input type="file" id="template-file" accept=".todo,.json">
            <button onclick="uploadTemplate()" style="margin-top: 0.5rem;">Upload Template</button>
        </div>
        
        <div class="modal-actions">
            <button class="secondary" onclick="hideModal('template')">Close</button>
        </div>
    </div>
</div>

<!-- Note Modal -->
<div class="overlay" id="note-overlay"></div>
<div class="modal" id="note-modal">
    <h3>Task Notes</h3>
    <div class="modal-content">
        <div id="note-item-title" style="font-weight: bold; margin-bottom: 1rem;"></div>
        <textarea id="note-content" placeholder="Add your notes here..." style="width: 100%; height: 200px; padding: 0.8rem; border: 1px solid var(--border-color); border-radius: 8px; font-family: inherit;"></textarea>
<div class="modal-actions">
    <button onclick="saveNote()">Save</button>
    <!-- Add these two new buttons -->
    <button onclick="insertBulletPoint()" class="bullet-btn" title="Insert bullet point">‚Ä¢</button>
    <button onclick="insertNumberedPoint()" class="numbered-btn" title="Insert numbered point">1.</button>
    <button class="secondary" onclick="hideModal('note')">Close</button>
</div>
    </div>
</div>

<!-- Floating Scroll Buttons -->
<button id="scroll-down-btn" onclick="scrollToSaved()">‚Üì</button>
<button id="floating-down-btn" onclick="scrollToSaved()" title="Scorol to Saved file">‚Üì</button>
<button id="floating-save-btn" onclick="saveToFile()" title="Saved file">üíæ</button>
<button id="floating-load-btn" onclick="loadFromFile()" title="Loading files from a selected folder">üìÇ</button>
<button id="floating-toggle-btn" onclick="toggleAllSections()" title="Toggle Sections">üîΩ</button>
<button id="floating-toggleview-btn" onclick="toggleCleanView()" title="Toggle Veiw">üëÅÔ∏è </button>
<button id="floating-up-btn" onclick="scrollToTop()" title="Scorol to Top">‚Üë</button>
<button id="scroll-up-btn" onclick="scrollToTop()">‚Üë</button>



<div id="dynalist-help-modal" class="modal">
  <h3>How to Connect to Dynalist</h3>
  <div class="modal-content">
    <div class="help-section">
      <h4>1. Get your API Key</h4>
      <p>Go to <a href="https://dynalist.io/developer" target="_blank">Dynalist Developer Page</a><br>
      Copy your personal API key.</p>
    </div>
    <div class="help-section">
      <h4>2. Get your Document ID</h4>
      <p>Open the Dynalist document you want to export into.<br>
      The URL looks like: <code>https://dynalist.io/d/AbCdEfGhIjKlMnOpQrStUv</code><br>
      ‚Üí The part after <code>/d/</code> is your Document ID.</p>
    </div>
    <div class="help-section">
      <h4>3. Paste into this app</h4>
      <p>When exporting, you‚Äôll be prompted to enter your API key and Document ID.<br>
      They are stored locally in your browser (never shared).</p>
    </div>
    <p>‚úÖ After setup, click <b>Export to Dynalist</b> and your tasks will appear in Dynalist.</p>
    <div class="modal-actions">
      <button class="secondary" onclick="hideDynalistHelp()">Close</button>
    </div>
  </div>
</div>

</body>
</html>