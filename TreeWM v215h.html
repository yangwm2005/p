<!DOCTYPE html>
<html>
<head>
<style>
    body { 
        font-family: 'Roboto', 'Segoe UI', 'Arial', sans-serif;
        background: linear-gradient(to bottom, #f8f9fa, #e9ecef);
        margin: 0; 
        padding: 20px; 
    }
    .outline-container { 
        width: 800px; 
        margin: 0 auto; 
        border: 1px solid #d1d5db;
        background: linear-gradient(to bottom, #ffffff, #f8fafc);
        box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        position: relative; 
        min-width: 400px; 
        height: 500px; 
        min-height: 200px; 
        border-radius: 10px;
        padding: 15px;
        display: flex; 
        flex-direction: column; 
    }
    .controls-container { 
        position: sticky; 
        top: 0; 
        background: #fff; 
        z-index: 10; 
        padding-bottom: 10px; 
        border-bottom: 1px solid #e5e7eb;
    }
    .outline-title { 
        width: 100%; 
        padding: 8px; 
        font-size: 18px; 
        font-weight: 500;
        border: 1px solid #d1d5db; 
        border-radius: 6px;
        margin-bottom: 10px; 
        box-sizing: border-box; 
        transition: border-color 0.2s;
    }
    .outline-title:focus { 
        outline: none; 
        border-color: #3b82f6;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
    }
    .outline-list { 
        list-style: none; 
        padding: 0; 
        margin: 0; 
        flex-grow: 1; 
        overflow-x: auto; 
        overflow-y: auto; 
        white-space: nowrap; 
    }
    .outline-item { 
        padding: 1px;
        margin: 0px 0; 
        cursor: move; 
        display: flex; 
        align-items: flex-start; 
        position: relative; 
        min-height: 22px; 
        flex-direction: row; 
        flex-wrap: nowrap; 
        border-radius: 6px; 
        overflow: visible; 
        transition: background 0.2s;
    }
    .outline-item:hover { 
        background: #f1f5f9;
    }
    .content-wrapper { 
        display: flex; 
        align-items: flex-start; 
        flex-grow: 0; 
        flex-shrink: 0; 
        position: relative; 
        overflow: visible; 
    }
    .content-wrapper::before { 
        content: '•'; 
        color: #6b7280; 
        font-size: 24px; 
        position: absolute; 
        left: -3px; 
        top: -3px; 
    }
    .checkbox { 
        margin-left: 5px; 
        margin-right: 0px; 
        flex-shrink: 0; 
    }
    .content {
        min-width: 100px;
        width: 150px;
        margin-left: 5px;
        white-space: pre-wrap;
        padding: 2px 4px; 
        position: relative;
        font-size: 14px;
        display: block; 
        box-sizing: border-box;
        max-width: 100%;
        color: #1f2937;
        line-height: 1.4; 
        min-height: 20px;
    }
    .content br {
        display: block;
        margin-bottom: 0;
    }
    .content:empty::before { 
        content: attr(placeholder); 
        color: #9ca3af;
        position: absolute;
        top: 2px;
        left: 4px;
    }
    .outline-item:not(.level-1):not(.level-2):not(.level-3):not(.level-4) > .content-wrapper > .content { width: 150px; }
    .outline-item.level-1 > .content-wrapper > .content { width: 150px; }
    .outline-item.level-2 > .content-wrapper > .content { width: 150px; }
    .outline-item.level-3 > .content-wrapper > .content { width: 150px; }
    .outline-item.level-4 > .content-wrapper > .content { width: 150px; }
    .level-1 .content, .level-2 .content, .level-3 .content, .level-4 .content { margin-left: 5px; }
    .content[contenteditable="true"]:focus { 
        outline: none; 
        border: 1px solid #3b82f6; 
        background: #fff; 
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2); 
        border-radius: 4px; 
    }
    .outline-item.has-children .content::after {
        content: '';
        position: absolute;
        left: calc(100% + 2px);
        right: 15px;
        height: 1px;
        background: repeating-linear-gradient(90deg, #9ca3af 0px, #9ca3af 2px, transparent 2px, transparent 4px);
        top: 50%;
        transform: translateY(-50%);
        z-index: 1;
    }
    .outline-item.has-children.clicked .content::after { content: ''; }
    .toggle-btn { 
        cursor: pointer; 
        width: 12px; 
        height: 22px; 
        line-height: 22px; 
        text-align: center; 
        font-family: monospace; 
        color: #6b7280; 
        flex-shrink: 0; 
        margin-left: 3px; 
        user-select: none; 
        font-size: 8px; 
    }
    .no-toggle { 
        width: 12px; 
        flex-shrink: 0; 
        margin-left: 3px; 
    }
    .hidden > .outline-list { display: none; }
    button { 
        margin: 0 4px 4px 0;
        padding: 4px 8px;
        background: linear-gradient(#3b82f6, #2563eb);
        color: white; 
        border: none; 
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        transition: background 0.2s, transform 0.1s;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        position: relative;
        display: inline-block;
        opacity: 1;
    }
    button:hover { 
        background: linear-gradient(#2563eb, #1e40af);
        transform: translateY(-1px);
    }
    button:active { 
        transform: translateY(0);
    }
    button[title]:hover:after {
        content: attr(title);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: #1f2937;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 11px;
        white-space: nowrap;
        z-index: 1000;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
    }
    button[title]:hover:after {
        opacity: 1;
        transition-delay: 0.3s;
    }
    #colorBlackBtn { background: linear-gradient(#4b5563, #1f2937); }
    #colorRedBtn { background: linear-gradient(#ef4444, #dc2626); }
    #colorBlueBtn { background: linear-gradient(#3b82f6, #2563eb); }
    #boldBtn { background: linear-gradient(#6b7280, #4b5563); }
    #highlightYellowBtn { background: linear-gradient(#facc15, #eab308); }
    #highlightOrangeBtn { background: linear-gradient(#f97316, #ea580c); }
    #toggleCheckboxesBtn { background: linear-gradient(#06b6d4, #0891b2); }
    #pdfOpenBtn { background: linear-gradient(#22c55e, #16a34a); }
    #pdfDownloadBtn { background: linear-gradient(#06b6d4, #0891b2); }
    #deleteBtn { background: linear-gradient(#ef4444, #dc2626); }
    #helpBtn { background: linear-gradient(#6b7280, #4b5563); }
    #undoBtn { background: linear-gradient(#f59e0b, #d97706); }
    #redoBtn { background: linear-gradient(#f59e0b, #d97706); }
    #printBtn { background: linear-gradient(#8b5cf6, #7c3aed); }
    #saveBtn { background: linear-gradient(#10b981, #059669); }
    #loadBtn { background: linear-gradient(#8b5cf6, #7c3aed); }
    #newLineBtn { background: linear-gradient(#ec4899, #db2777); }
    #newLineBtn:hover { background: linear-gradient(#db2777, #be185d); }
    #pasteAsItemsBtn { background: linear-gradient(#14b8a6, #0d9488); }
    #pasteAsItemsBtn:hover { background: linear-gradient(#0d9488, #0f766e); }
    #toggleFormattingBtn { background: linear-gradient(#a855f7, #9333ea); }
    #toggleFormattingBtn.active { box-shadow: 0 0 8px rgba(168, 85, 247, 0.5); }
    #fontSizeBtn, #fontFamilyBtn, #allFontSizeBtn, #allFontFamilyBtn {
        background: linear-gradient(#d946ef, #c026d3);
    }
    #fontSizeBtn:hover, #fontFamilyBtn:hover, #allFontSizeBtn:hover, #allFontFamilyBtn:hover {
        background: linear-gradient(#c026d3, #a21caf);
    }
#pdfFitAllStyledOpenBtn { 
    background: linear-gradient(#22c55e, #16a34a); 
}
#pdfFitAllStyledOpenBtn:hover { 
    background: linear-gradient(#16a34a, #15803d); 
}
    .outline-list { 
        padding-left: 20px; 
        position: relative; 
    }
    .outline-list::before { 
        content: ''; 
        position: absolute; 
        top: 0; 
        bottom: 0; 
        left: 7px; 
        width: 1px; 
        background: #d1d5db; 
        z-index: 0; 
    }
    .outline-item::before { 
        content: ''; 
        position: absolute; 
        top: 11px; 
        left: -12px; 
        width: 12px; 
        height: 1px; 
        background: #d1d5db; 
        z-index: 1; 
    }
    .outline-list > .outline-item:first-child::after { 
        content: ''; 
        position: absolute; 
        top: 0; 
        left: -13px; 
        width: 1px; 
        height: 11px; 
        background: #f8fafc; 
        z-index: 2; 
    }
    .outline-list > .outline-item:last-child::after { 
        content: ''; 
        position: absolute; 
        bottom: 0; 
        top: 11px; 
        left: -13px; 
        width: 1px; 
        background: #f8fafc; 
        z-index: 2; 
    }
    .outline-list > .outline-item:only-child::after { 
        top: 0; 
        bottom: 0; 
        background: #f8fafc; 
    }
    .drag-over { 
        border: 2px dashed #3b82f6; 
    }
    .resize-bar-container { 
        height: 25px; 
        position: relative; 
        margin-bottom: 15px; 
        border-bottom: 1px solid #e5e7eb; 
        overflow-x: auto; 
        white-space: nowrap; 
        background: #f1f5f9;
    }
    .resize-bar { 
        height: 20px; 
        background: #e5e7eb;
        position: absolute; 
        border-right: 1px solid #d1d5db; 
        top: 0; 
        border-radius: 4px; 
    }
    .resize-bar-handle { 
        width: 5px; 
        height: 100%; 
        background: #9ca3af; 
        cursor: col-resize; 
        position: absolute; 
        right: -2.5px; 
        top: 0; 
        transition: background 0.2s; 
    }
    .resize-bar-handle:hover { 
        background: #6b7280; 
    }
    .resize-bar-label { 
        text-align: center; 
        font-size: 12px; 
        color: #4b5563; 
        padding: 2px; 
        width: 100%; 
        overflow: hidden; 
        text-overflow: ellipsis; 
        display: block; 
    }
    .resize-bar-label:focus { 
        outline: none; 
        border: 1px solid #3b82f6; 
        background: white; 
        border-radius: 2px; 
    }
    .resize-handle { 
        position: absolute; 
        bottom: 0; 
        right: 0; 
        width: 12px; 
        height: 12px;
        background: #9ca3af; 
        cursor: nwse-resize; 
        border-radius: 0 0 10px 0;
        transition: background 0.2s; 
    }
    .resize-handle:hover { 
        background: #6b7280; 
    }
    .status-bar { 
        font-size: 12px; 
        color: #4b5563; 
        padding: 8px 10px; 
        border-top: 1px solid #e5e7eb; 
        background: #f1f5f9; 
        border-radius: 0 0 10px 10px; 
        font-weight: 500;
    }
    .modal { 
        display: none; 
        position: fixed; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        background: rgba(0,0,0,0.4);
        justify-content: center; 
        align-items: center; 
    }
    .modal-content { 
        background: #fff; 
        padding: 25px; 
        border-radius: 10px; 
        max-width: 450px; 
        box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        font-family: 'Roboto', 'Segoe UI', 'Arial', sans-serif;
    }
    .modal-content h2 { 
        margin-top: 0; 
        font-size: 20px; 
        color: #1f2937; 
        font-weight: 500; 
    }
    .modal-content ul { 
        list-style: none; 
        padding: 0; 
        color: #4b5563; 
    }
    .modal-content li { 
        margin: 8px 0; 
        line-height: 1.5; 
    }
    .close-btn { 
        float: right; 
        cursor: pointer; 
        font-size: 20px; 
        color: #6b7280; 
        transition: color 0.2s; 
    }
    .close-btn:hover { 
        color: #1f2937; 
    }
    .content span { 
        color: inherit; 
    }
    .dropdown {
        position: absolute;
        background: #fff;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        z-index: 1000;
        padding: 5px 0;
        display: none;
        min-width: 100px;
    }
    .dropdown-item {
        padding: 4px 10px;
        font-size: 12px;
        color: #1f2937;
        cursor: pointer;
        transition: background 0.2s;
    }
    .dropdown-item:hover {
        background: #f1f5f9;
    }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&family=Open+Sans:wght@400&display=swap" rel="stylesheet">
</head>
<body>
<div class="outline-container">
    <div class="controls-container">
        <input type="text" class="outline-title" placeholder="Welcome to Dr. Yang's Tree organiztaion. Please Enter Outline Title" value="">
        <div>
            <button id="addMainBtn" title="Add a new main item">+ Main</button>
            <button id="addSubBtn" title="Add a sub-item to selected item (Shift + Enter)">+ Sub</button>
            <button id="addSiblingBtn" title="Add a sibling item to selected item (Enter)">+ Sibling</button>
            <button id="colorBlackBtn" title="Set text color to black">B</button>
            <button id="colorRedBtn" title="Set text color to red">R</button>
            <button id="colorBlueBtn" title="Set text color to blue">B</button>
            <button id="boldBtn" title="Toggle bold on selected text (Ctrl + B)">Bold</button>
            <button id="highlightYellowBtn" title="Highlight selected text yellow (Ctrl + H)">H-Yellow</button>
            <button id="highlightOrangeBtn" title="Highlight selected text orange (Ctrl + Shift + H)">H-Orange</button>
            <button id="toggleCheckboxesBtn" title="Add or remove checkboxes (Ctrl + T)">✅</button>
            <button id="newLineBtn" title="Insert a new line in the current item (Ctrl + Enter)">↵</button>
            <button id="pasteAsItemsBtn" title="Paste text as individual items or sub-items (Ctrl + Shift + V)">Paste as Items</button>
            <button id="toggleFormattingBtn" title="Toggle formatting mode (Ctrl + F)">✍️</button>
            <button id="fontSizeBtn" title="Font size for selected item or text">Size ▼</button>
            <button id="fontFamilyBtn" title="Font family for selected item or text">Font ▼</button>
            <button id="allFontSizeBtn" title="Font size for all items">All Size ▼</button>
            <button id="allFontFamilyBtn" title="Font family for all items">All Font ▼</button>
            <button id="saveBtn" title="Save outline as .wmtree">Save</button>
            <button id="loadBtn" title="Load outline from .wmtree or .json">Load</button>
            <button id="printBtn" title="Print outline">Print</button>
            <button id="exportOPMLBtn" title="Export as OPML">Exp OPML</button>
            <button id="importOPMLBtn" title="Import from OPML">Imp OPML</button>
            <button id="pdfOpenBtn" title="Open outline as PDF with short one">PDF Open</button>
            <button id="pdfDownloadBtn" title="Download outline as PDF">PDF Download</button>
            <button id="deleteBtn" title="Delete selected item (Shift + Delete)">Delete</button>
            <button id="undoBtn" title="Undo last action (Ctrl + Z)">Undo</button>
            <button id="redoBtn" title="Redo last action (Ctrl + Y)">Redo</button>
            <button id="helpBtn" title="Show keyboard shortcuts">Help</button>
        </div>
    </div>
    <div class="resize-bar-container" id="resizeBarContainer"></div>
    <ul class="outline-list" id="outlineList">
        <li class="outline-item" draggable="true">
            <div class="content-wrapper">
                <span class="content" contenteditable="true" placeholder="New main item"></span>
            </div>
            <span class="no-toggle"></span>
            <ul class="outline-list"></ul>
        </li>
    </ul>
    <div class="resize-handle"></div>
    <div class="status-bar" id="statusBar">Items: 1 | Last Action: Loaded</div>
</div>

<div class="modal" id="helpModal">
    <div class="modal-content">
        <span class="close-btn" id="closeModal">×</span>
        <h2>Keyboard Shortcuts</h2>
        <p style="color: #6b7280; margin: 0 0 10px;">Use these shortcuts to work faster!</p>
        <ul>
            <li><strong>Enter</strong>: Add a sibling item</li>
            <li><strong>Shift + Enter</strong>: Add a sub-item</li>
            <li><strong>Ctrl + Enter</strong>: Insert a new line</li>
            <li><strong>Shift + Delete</strong>: Delete selected item</li>
            <li><strong>Tab</strong>: Move to next item</li>
            <li><strong>Up/Down</strong>: Navigate items</li>
            <li><strong>Ctrl + Up/Down</strong>: Move cursor between lines</li>
            <li><strong>Ctrl + Left/Right</strong>: Move cursor by word</li>
            <li><strong>Shift + Arrows</strong>: Select text</li>
            <li><strong>Ctrl + Z</strong>: Undo action</li>
            <li><strong>Ctrl + Y</strong>: Redo action</li>
            <li><strong>Ctrl + B</strong>: Toggle bold text</li>
            <li><strong>Ctrl + H</strong>: Highlight yellow</li>
            <li><strong>Ctrl + Shift + H</strong>: Highlight orange</li>
            <li><strong>Ctrl + T</strong>: Toggle checkboxes</li>
            <li><strong>Ctrl + F</strong>: Toggle formatting mode</li>
            <li><strong>Ctrl + Shift + V</strong>: Paste text as individual items or sub-items</li>
        </ul>
    </div>
</div>

<div class="modal" id="orientationModal">
    <div class="modal-content">
        <span class="close-btn" id="closeOrientationModal">×</span>
        <h2>Select PDF Orientation</h2>
        <p style="color: #6b7280; margin: 0 0 10px;">Choose how you’d like your PDF to be oriented:</p>
        <div style="text-align: center; margin-top: 15px;">
            <button id="portraitBtn" style="margin: 0 10px;">Portrait</button>
            <button id="landscapeBtn" style="margin: 0 10px; background: linear-gradient(#10b981, #059669);">Landscape</button>
            <button id="cancelOrientationBtn" style="margin: 0 10px; background: linear-gradient(#ef4444, #dc2626);">Cancel</button>
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <label style="color: #4b5563; font-size: 12px;">
                <input type="checkbox" id="fitAllCheckbox" style="margin-right: 5px;"> Fit All Pages
            </label>
        </div>
    </div>
</div>

<script>
    const { jsPDF } = window.jspdf;
    const outlineList = document.getElementById('outlineList');
    const outlineTitle = document.querySelector('.outline-title');
    const resizeBarContainer = document.getElementById('resizeBarContainer');
    const outlineContainer = document.querySelector('.outline-container');
    const statusBar = document.getElementById('statusBar');
    const helpModal = document.getElementById('helpModal');
    const closeModal = document.getElementById('closeModal');
    let draggedItem = null;
    let resizingLevel = null;
    let startX = 0;
    let startWidth = 0;
    let currentItem = null;
    const levelWidths = { '0': 160, '1': 150, '2': 150, '3': 150, '4': 150 };
    const levelNames = ['Main Items', 'Level 1', 'Level 2', 'Level 3', 'Level 4'];
    let history = [];
    let historyIndex = -1;
    let isApplyingColor = false;
    let hasCheckboxes = false;
    let formattingEnabled = false;
    const CHECKBOX_WIDTH = 20;
    let activeDropdown = null;

    function saveState(action) {
        const state = {
            title: outlineTitle.value,
            items: serializeItems(outlineList.children),
            hasCheckboxes: hasCheckboxes,
            formattingEnabled: formattingEnabled,
            levelNames: [...levelNames],
            action: action
        };
        if (historyIndex < history.length - 1) {
            history = history.slice(0, historyIndex + 1);
        }
        history.push(state);
        historyIndex++;
        updateStatus(action);
    }

    function undo() {
        if (historyIndex > 0) {
            historyIndex--;
            const state = history[historyIndex];
            outlineTitle.value = state.title;
            hasCheckboxes = state.hasCheckboxes;
            formattingEnabled = state.formattingEnabled;
            if (state.levelNames && Array.isArray(state.levelNames)) {
                levelNames.length = 0;
                levelNames.push(...state.levelNames);
            }
            outlineList.innerHTML = '';
            deserializeItems(state.items, outlineList);
            updateItemStates();
            updateResizeBars();
            updateFormattingMode();
            currentItem = outlineList.querySelector('.outline-item');
            if (currentItem) currentItem.querySelector('.content').focus();
            updateStatus(`Undid ${state.action}`);
        }
    }

    function redo() {
        if (historyIndex < history.length - 1) {
            historyIndex++;
            const state = history[historyIndex];
            outlineTitle.value = state.title;
            hasCheckboxes = state.hasCheckboxes;
            formattingEnabled = state.formattingEnabled;
            if (state.levelNames && Array.isArray(state.levelNames)) {
                levelNames.length = 0;
                levelNames.push(...state.levelNames);
            }
            outlineList.innerHTML = '';
            deserializeItems(state.items, outlineList);
            updateItemStates();
            updateResizeBars();
            updateFormattingMode();
            currentItem = outlineList.querySelector('.outline-item');
            if (currentItem) currentItem.querySelector('.content').focus();
            updateStatus(`Redid ${state.action}`);
        }
    }

    function updateStatus(action) {
        const itemCount = outlineList.querySelectorAll('.outline-item').length;
        statusBar.textContent = `Items: ${itemCount} | Last Action: ${action}`;
    }

    function createItem(text = '', level = 0, checked = false) {
        const li = document.createElement('li');
        li.className = `outline-item${level > 0 ? ` level-${level}` : ''}`;
        li.draggable = true;
        const placeholder = level === 0 ? 'New main item' : 'New sub-item';
        let checkboxHTML = hasCheckboxes ? `<input type="checkbox" class="checkbox"${checked ? ' checked' : ''}>` : '';
        li.innerHTML = `
            <div class="content-wrapper">
                ${checkboxHTML}
                <span class="content" contenteditable="true" placeholder="${placeholder}">${text}</span>
            </div>
            <span class="no-toggle"></span>
            <ul class="outline-list"></ul>
        `;
        const content = li.querySelector('.content');
        content.style.width = `${levelWidths[level] - (hasCheckboxes ? CHECKBOX_WIDTH : 0)}px`;
        content.addEventListener('click', (e) => {
            e.stopPropagation();
            currentItem = li;
            li.classList.add('clicked');
            updateItemHeight(li);
        });
        content.addEventListener('blur', () => li.classList.remove('clicked'));
        content.addEventListener('input', () => {
            updateItemHeight(li);
            saveState('Edited Content');
        });
        content.addEventListener('paste', stripFormatting);
        const toggle = li.querySelector('.no-toggle');
        toggle.addEventListener('click', (e) => {
            e.stopPropagation();
            if (toggle.classList.contains('toggle-btn')) {
                const item = toggle.closest('.outline-item');
                item.classList.toggle('hidden');
                toggle.textContent = item.classList.contains('hidden') ? '▶' : '▼';
            }
        });
        updateItemHeight(li);
        return li;
    }

    function updateItemHeight(item) {
        const content = item.querySelector('.content');
        content.style.height = 'auto';
        const minHeight = 20;
        content.style.height = `${Math.max(minHeight, content.scrollHeight)}px`;
    }

    function updateResizeBars() {
        const items = outlineList.querySelectorAll('.outline-item');
        let maxLevel = 0;
        items.forEach(item => {
            const level = parseInt(item.className.match(/level-(\d)/)?.[1] || 0);
            maxLevel = Math.max(maxLevel, level);
        });
        resizeBarContainer.innerHTML = '';
        let leftOffset = 32;
        let totalWidth = 0;
        for (let i = 0; i <= maxLevel; i++) {
            const bar = document.createElement('div');
            bar.className = 'resize-bar';
            bar.dataset.level = i;
            bar.style.left = `${leftOffset}px`;
            bar.style.width = `${levelWidths[i]}px`;
            bar.innerHTML = `<span class="resize-bar-label" contenteditable="true">${levelNames[i]}</span><span class="resize-bar-handle"></span>`;
            resizeBarContainer.appendChild(bar);
            const label = bar.querySelector('.resize-bar-label');
            label.addEventListener('blur', () => levelNames[i] = label.textContent.trim() || (i === 0 ? 'Main Items' : `Level ${i}`));
            label.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); label.blur(); } });
            leftOffset += levelWidths[i] + 45;
            totalWidth = leftOffset;
        }
        resizeBarContainer.style.minWidth = `${totalWidth}px`;
        document.querySelectorAll('.outline-item .content').forEach(content => {
            const level = content.closest('.outline-item').className.match(/level-(\d)/)?.[1] || '0';
            content.style.width = `${levelWidths[level] - (hasCheckboxes ? CHECKBOX_WIDTH : 0)}px`;
        });
        updateOutlineListWidth();
    }

    function updateOutlineListWidth() {
        const maxLevel = Math.max(...Array.from(outlineList.querySelectorAll('.outline-item'))
            .map(item => parseInt(item.className.match(/level-(\d)/)?.[1] || 0)));
        let totalWidth = 29;
        for (let i = 0; i <= maxLevel; i++) {
            totalWidth += levelWidths[i] + 41;
        }
        outlineList.style.minWidth = `${totalWidth}px`;
    }

    resizeBarContainer.addEventListener('mousedown', (e) => {
        const handle = e.target.closest('.resize-bar-handle');
        if (handle) {
            e.preventDefault();
            const bar = handle.closest('.resize-bar');
            resizingLevel = bar.dataset.level;
            startX = e.pageX;
            startWidth = levelWidths[resizingLevel];
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', stopResize);
        }
    });

    function resize(e) {
        if (resizingLevel !== null) {
            const diff = e.pageX - startX;
            const newWidth = Math.max(120, startWidth + diff);
            levelWidths[resizingLevel] = newWidth;
            const selector = resizingLevel === '0'
                ? '.outline-item:not(.level-1):not(.level-2):not(.level-3):not(.level-4) > .content-wrapper > .content'
                : `.outline-item.level-${resizingLevel} > .content-wrapper > .content`;
            document.querySelectorAll(selector).forEach(el => el.style.width = `${newWidth - (hasCheckboxes ? CHECKBOX_WIDTH : 0)}px`);
            const bars = Array.from(resizeBarContainer.querySelectorAll('.resize-bar'));
            let leftOffset = 32;
            bars.forEach(bar => {
                const level = parseInt(bar.dataset.level);
                bar.style.width = `${levelWidths[level]}px`;
                bar.style.left = `${leftOffset}px`;
                leftOffset += levelWidths[level] + 45;
            });
            updateOutlineListWidth();
            updateStatus(`Resized Level ${resizingLevel} to ${newWidth}px`);
        }
    }

    function stopResize() {
        resizingLevel = null;
        document.removeEventListener('mousemove', resize);
        document.removeEventListener('mouseup', stopResize);
        saveState('Resized Level Width');
    }

    function toggleCheckboxes() {
        hasCheckboxes = !hasCheckboxes;
        const items = Array.from(outlineList.querySelectorAll('.outline-item'));
        items.forEach(item => {
            const wrapper = item.querySelector('.content-wrapper');
            const content = item.querySelector('.content');
            const existingCheckbox = item.querySelector('.checkbox');
            const level = item.className.match(/level-(\d)/)?.[1] || '0';
            if (hasCheckboxes && !existingCheckbox) {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'checkbox';
                wrapper.insertBefore(checkbox, content);
                levelWidths[level] += CHECKBOX_WIDTH;
            } else if (!hasCheckboxes && existingCheckbox) {
                existingCheckbox.remove();
                levelWidths[level] = Math.max(100, levelWidths[level] - CHECKBOX_WIDTH);
            }
            content.style.width = `${levelWidths[level] - (hasCheckboxes ? CHECKBOX_WIDTH : 0)}px`;
            updateItemHeight(item);
        });
        updateResizeBars();
        saveState(hasCheckboxes ? 'Added Checkboxes' : 'Removed Checkboxes');
    }

    document.getElementById('addMainBtn').addEventListener('click', () => {
        const newItem = createItem();
        outlineList.appendChild(newItem);
        updateItemState(newItem);
        updateResizeBars();
        const content = newItem.querySelector('.content');
        content.focus();
        currentItem = newItem;
        saveState('Added Main Item');
    });

    document.getElementById('addSubBtn').addEventListener('click', (e) => {
        e.stopPropagation();
        if (currentItem) {
            const subList = currentItem.querySelector('.outline-list');
            const level = currentItem.className.match(/level-(\d)/)?.[1] || 0;
            const newSubItem = createItem('', parseInt(level) + 1);
            subList.appendChild(newSubItem);
            updateItemState(currentItem);
            updateResizeBars();
            const newContent = newSubItem.querySelector('.content');
            newContent.focus();
            currentItem = newSubItem;
            saveState('Added Sub-Item');
        } else {
            alert('Please select an item to add a sub-item.');
        }
    });

    document.getElementById('addSiblingBtn').addEventListener('click', (e) => {
        e.stopPropagation();
        if (currentItem) {
            const parentList = currentItem.parentElement;
            const level = currentItem.className.match(/level-(\d)/)?.[1] || 0;
            const newSiblingItem = createItem('', parseInt(level));
            currentItem.after(newSiblingItem);
            updateItemState(newSiblingItem);
            updateResizeBars();
            const newContent = newSiblingItem.querySelector('.content');
            newContent.focus();
            currentItem = newSiblingItem;
            saveState('Added Sibling Item');
        } else {
            alert('Please select an item to add a sibling item.');
        }
    });

    document.getElementById('toggleCheckboxesBtn').addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        toggleCheckboxes();
    });

    document.getElementById('newLineBtn').addEventListener('click', (e) => {
        e.preventDefault();
        if (currentItem) {
            const content = currentItem.querySelector('.content');
            content.focus();
            const selection = window.getSelection();
            const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : document.createRange();
            const br = document.createElement('br');
            if (content.innerHTML === '' || content.innerHTML === '<br>') {
                content.innerHTML = '';
                content.appendChild(br);
                range.selectNodeContents(content);
                range.collapse(false);
            } else {
                range.insertNode(br);
                range.setStartAfter(br);
                range.setEndAfter(br);
            }
            selection.removeAllRanges();
            selection.addRange(range);
            setTimeout(() => {
                updateItemHeight(currentItem);
                content.scrollTop = content.scrollHeight;
                saveState('Inserted Line Break');
            }, 0);
        } else {
            alert('Please select an item to insert a new line.');
        }
    });

function pasteAsItems(asSubItems = false) {
    navigator.clipboard.readText().then(text => {
        processPastedText(text, asSubItems);
    }).catch(err => {
        console.error('Failed to read clipboard:', err);
        const manualText = prompt('Unable to access clipboard automatically. Please paste your text here:');
        if (manualText !== null) {
            processPastedText(manualText, asSubItems);
        }
    });
}

function processPastedText(text, asSubItems) {
    if (!text) {
        alert('No text provided.');
        return;
    }

    const lines = text.split('\n').filter(line => line.trim() !== '');
    if (lines.length === 0) {
        alert('No valid content to paste.');
        return;
    }

    // Parse lines into a hierarchical structure
    const itemsTree = [];
    const stack = [{ level: -1, children: itemsTree }]; // Stack to track nesting levels

    lines.forEach(line => {
        // Determine indentation level (count leading tabs or assume 4 spaces = 1 level)
        const trimmedLine = line.trim();
        const indentMatch = line.match(/^(\t+|\s{4,})/);
        const indentLevel = indentMatch ? indentMatch[0].replace(/\s{4}/g, '\t').length : 0;
        const content = trimmedLine.replace(/^[-•*]\s+/, ''); // Remove common bullet markers

        // Adjust stack based on indentation level
        while (stack.length > 1 && indentLevel <= stack[stack.length - 1].level) {
            stack.pop();
        }

        const newItem = { text: content, level: indentLevel, children: [] };
        stack[stack.length - 1].children.push(newItem);
        stack.push(newItem);
    });

    // Determine base level and target list
    let targetList = outlineList;
    let baseLevel = 0;
    if (asSubItems && currentItem) {
        targetList = currentItem.querySelector('.outline-list');
        baseLevel = parseInt(currentItem.className.match(/level-(\d)/)?.[1] || 0) + 1;
    }

    // Convert tree to outline items
    function createItemsFromTree(nodes, parentList, levelOffset) {
        nodes.forEach(node => {
            const itemLevel = baseLevel + (node.level - (itemsTree[0]?.level || 0)) + levelOffset;
            const newItem = createItem(node.text, itemLevel);
            parentList.appendChild(newItem);
            updateItemState(newItem);
            if (node.children.length > 0) {
                createItemsFromTree(node.children, newItem.querySelector('.outline-list'), 0);
            }
        });
    }

    createItemsFromTree(itemsTree, targetList, 0);
    updateResizeBars();

    // Focus on the last top-level item pasted
    const lastItem = targetList.lastElementChild;
    if (lastItem) {
        const content = lastItem.querySelector('.content');
        content.focus();
        currentItem = lastItem;
    }

    saveState(`Pasted as ${asSubItems ? 'Sub-Items' : 'Main Items'} with Hierarchy`);
}

// Keep the existing event listener
document.getElementById('pasteAsItemsBtn').addEventListener('click', (e) => {
    e.preventDefault();
    const asSubItems = currentItem && confirm('Paste as sub-items of the selected item? Click "Cancel" to paste as main items.');
    pasteAsItems(asSubItems);
});

    document.getElementById('colorBlackBtn').addEventListener('click', (e) => {
        e.preventDefault();
        applyColor('black');
    });

    document.getElementById('colorRedBtn').addEventListener('click', (e) => {
        e.preventDefault();
        applyColor('red');
    });

    document.getElementById('colorBlueBtn').addEventListener('click', (e) => {
        e.preventDefault();
        applyColor('blue');
    });

    document.getElementById('boldBtn').addEventListener('click', (e) => {
        e.preventDefault();
        applyBold();
    });

    document.getElementById('highlightYellowBtn').addEventListener('click', (e) => {
        e.preventDefault();
        applyHighlight('yellow');
    });

    document.getElementById('highlightOrangeBtn').addEventListener('click', (e) => {
        e.preventDefault();
        applyHighlight('orange');
    });

    document.getElementById('toggleFormattingBtn').addEventListener('click', (e) => {
        e.preventDefault();
        formattingEnabled = !formattingEnabled;
        document.getElementById('toggleFormattingBtn').classList.toggle('active', formattingEnabled);
        updateFormattingMode();
        saveState(formattingEnabled ? 'Enabled Formatting' : 'Disabled Formatting');
    });

    const fontSizeBtn = document.getElementById('fontSizeBtn');
    const fontFamilyBtn = document.getElementById('fontFamilyBtn');
    const allFontSizeBtn = document.getElementById('allFontSizeBtn');
    const allFontFamilyBtn = document.getElementById('allFontFamilyBtn');

    const fontSizes = [
        { label: '10', value: '10px' }, // Added new option
        { label: '11', value: '11px' }, // Added new option
        { label: '12', value: '12px' },
        { label: '14', value: '14px' },
        { label: '16', value: '16px' },
        { label: '18', value: '18px' }
    ];

const fontFamilies = [
    { label: 'Roboto', value: 'Roboto' },
    { label: 'Arial', value: 'Arial' },
    { label: 'Times New Roman', value: 'Times New Roman' },
    { label: 'Open Sans', value: 'Open Sans' } // Added new option
];

    function createDropdown(options, property, button, applyToAll = false) {
        if (activeDropdown) {
            activeDropdown.remove();
            activeDropdown = null;
        }
        const dropdown = document.createElement('div');
        dropdown.className = 'dropdown';
        dropdown.style.display = 'block';

        options.forEach(option => {
            const item = document.createElement('div');
            item.className = 'dropdown-item';
            item.textContent = option.label;
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                if (applyToAll) {
                    document.querySelectorAll('.outline-item .content').forEach(content => {
                        content.style[property] = option.value;
                        updateItemHeight(content.closest('.outline-item'));
                    });
                    saveState(`Applied ${property} ${option.value} to All`);
                } else {
                    if (!currentItem) {
                        alert('Please select an item.');
                    } else {
                        applyStyle(property, option.value);
                    }
                }
                dropdown.remove();
                activeDropdown = null;
            });
            dropdown.appendChild(item);
        });

        const rect = button.getBoundingClientRect();
        dropdown.style.top = `${rect.bottom + window.scrollY}px`;
        dropdown.style.left = `${rect.left + window.scrollX}px`;
        document.body.appendChild(dropdown);
        activeDropdown = dropdown;
    }

    fontSizeBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        createDropdown(fontSizes, 'fontSize', fontSizeBtn, false);
    });

    fontFamilyBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        createDropdown(fontFamilies, 'fontFamily', fontFamilyBtn, false);
    });

    allFontSizeBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        createDropdown(fontSizes, 'fontSize', allFontSizeBtn, true);
    });

    allFontFamilyBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        createDropdown(fontFamilies, 'fontFamily', allFontFamilyBtn, true);
    });

    document.addEventListener('click', (e) => {
        if (activeDropdown && !activeDropdown.contains(e.target) && 
            e.target !== fontSizeBtn && e.target !== fontFamilyBtn && 
            e.target !== allFontSizeBtn && e.target !== allFontFamilyBtn) {
            activeDropdown.remove();
            activeDropdown = null;
        }
    });

    document.getElementById('saveBtn').addEventListener('click', () => {
        const data = {
            title: outlineTitle.value,
            items: serializeItems(outlineList.children),
            hasCheckboxes: hasCheckboxes,
            formattingEnabled: formattingEnabled,
            levelNames: [...levelNames]
        };
        const jsonString = JSON.stringify(data);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${outlineTitle.value || 'outline'}.wmtree`;
        a.click();
        URL.revokeObjectURL(url);
        updateStatus('Saved as .wmtree');
    });

    document.getElementById('loadBtn').addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.wmtree, .json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (file) loadJSONFile(file);
        };
        input.click();
    });

    document.getElementById('printBtn').addEventListener('click', () => {
        window.print();
        updateStatus('Printed Outline');
    });

    document.getElementById('exportOPMLBtn').addEventListener('click', () => {
        exportOPML();
    });

    document.getElementById('importOPMLBtn').addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.opml';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (file) importOPML(file);
        };
        input.click();
    });

    document.getElementById('pdfOpenBtn').addEventListener('click', () => {
        const doc = generatePDF();
        const pdfBlob = doc.output('blob');
        const url = URL.createObjectURL(pdfBlob);
        window.open(url);
        updateStatus('Generated PDF');
    });

    document.getElementById('pdfDownloadBtn').addEventListener('click', () => {
        const doc = generatePDF();
        doc.save(`${outlineTitle.value || 'outline'}.pdf`);
        updateStatus('Downloaded PDF');
    });

    document.getElementById('deleteBtn').addEventListener('click', (e) => {
        e.stopPropagation();
        deleteCurrentItem();
    });

    document.getElementById('undoBtn').addEventListener('click', undo);
    document.getElementById('redoBtn').addEventListener('click', redo);

    document.getElementById('helpBtn').addEventListener('click', () => helpModal.style.display = 'flex');
    closeModal.addEventListener('click', () => helpModal.style.display = 'none');
    window.addEventListener('click', (e) => { if (e.target === helpModal) helpModal.style.display = 'none'; });

    outlineList.addEventListener('dragstart', (e) => {
        const item = e.target.closest('.outline-item');
        if (item) {
            draggedItem = item;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', '');
            setTimeout(() => item.style.opacity = '0.5', 0);
        }
    });

    outlineList.addEventListener('dragend', (e) => {
        if (draggedItem) {
            draggedItem.style.opacity = '1';
            draggedItem = null;
        }
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
    });

    outlineList.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    });

    outlineList.addEventListener('dragenter', (e) => {
        const target = e.target.closest('.outline-item');
        if (target && target !== draggedItem) {
            target.classList.add('drag-over');
        }
    });

    outlineList.addEventListener('dragleave', (e) => {
        const target = e.target.closest('.outline-item');
        if (target) {
            target.classList.remove('drag-over');
        }
    });

    outlineList.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const target = e.target.closest('.outline-item');
        if (draggedItem && target && draggedItem !== target) {
            const targetRect = target.getBoundingClientRect();
            const dropY = e.clientY;
            const isAbove = dropY < targetRect.top + targetRect.height / 2;
            const targetList = target.parentElement;
            const targetLevel = parseInt(target.className.match(/level-(\d)/)?.[1] || '0');

            draggedItem.className = `outline-item${targetLevel > 0 ? ` level-${targetLevel}` : ''}`;
            draggedItem.querySelector('.content').style.width = `${levelWidths[targetLevel] - (hasCheckboxes ? CHECKBOX_WIDTH : 0)}px`;

            if (isAbove) {
                targetList.insertBefore(draggedItem, target);
            } else {
                targetList.insertBefore(draggedItem, target.nextSibling);
            }

            updateItemStates();
            updateResizeBars();
            saveState('Reordered Item');
        }
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
    });

    outlineContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        outlineContainer.style.borderColor = '#3b82f6';
    });

    outlineContainer.addEventListener('dragleave', (e) => {
        outlineContainer.style.borderColor = '#d1d5db';
    });

    outlineContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        outlineContainer.style.borderColor = '#d1d5db';
        const files = e.dataTransfer.files;
        if (files.length > 0 && (files[0].name.endsWith('.wmtree') || files[0].type === 'application/json')) {
            loadJSONFile(files[0]);
        } else {
            alert('Please drop a valid .wmtree or .json file.');
        }
    });

    outlineList.addEventListener('keydown', (e) => {
        const content = e.target.closest('.content');
        if (!content) return;
        const item = content.closest('.outline-item');
        const level = parseInt(item.className.match(/level-(\d)/)?.[1] || 0);
        const allItems = Array.from(outlineList.getElementsByClassName('outline-item'));

        if (e.key === 'Enter' && !e.ctrlKey && !e.shiftKey) {
            e.preventDefault();
            const parentList = item.parentElement;
            const newItem = createItem('', level);
            item.after(newItem);
            updateItemState(newItem);
            updateResizeBars();
            const newContent = newItem.querySelector('.content');
            newContent.focus();
            currentItem = newItem;
            saveState('Added Sibling Item');
        } else if (e.key === 'Enter' && e.shiftKey) {
            e.preventDefault();
            const subList = item.querySelector('.outline-list');
            const newSubItem = createItem('', level + 1);
            subList.appendChild(newSubItem);
            updateItemState(item);
            updateResizeBars();
            const newContent = newSubItem.querySelector('.content');
            newContent.focus();
            currentItem = newSubItem;
            saveState('Added Sub-Item');
        } else if (e.key === 'Enter' && e.ctrlKey) {
            e.preventDefault();
            const selection = window.getSelection();
            const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : document.createRange();
            const br = document.createElement('br');
            if (content.innerHTML === '' || content.innerHTML === '<br>') {
                content.innerHTML = '';
                content.appendChild(br);
                range.selectNodeContents(content);
                range.collapse(false);
            } else {
                range.insertNode(br);
                range.setStartAfter(br);
                range.setEndAfter(br);
            }
            selection.removeAllRanges();
            selection.addRange(range);
            setTimeout(() => {
                updateItemHeight(item);
                content.scrollTop = content.scrollHeight;
                saveState('Inserted Line Break');
            }, 0);
        } else if (e.key === 'Delete' && e.shiftKey) {
            e.preventDefault();
            currentItem = item;
            deleteCurrentItem();
        } else if (e.key === 'Tab') {
            e.preventDefault();
            const currentIndex = allItems.indexOf(item);
            const nextContent = allItems[currentIndex + 1]?.querySelector('.content');
            if (nextContent) {
                nextContent.focus();
                placeCaretAtEnd(nextContent);
                currentItem = nextContent.closest('.outline-item');
            }
        } else if (e.key === 'ArrowUp' && !e.ctrlKey && !e.shiftKey) {
            e.preventDefault();
            const currentIndex = allItems.indexOf(item);
            const prevContent = allItems[currentIndex - 1]?.querySelector('.content');
            if (prevContent) {
                prevContent.focus();
                placeCaretAtEnd(prevContent);
                currentItem = prevContent.closest('.outline-item');
            }
        } else if (e.key === 'ArrowDown' && !e.ctrlKey && !e.shiftKey) {
            e.preventDefault();
            const currentIndex = allItems.indexOf(item);
            const nextContent = allItems[currentIndex + 1]?.querySelector('.content');
            if (nextContent) {
                nextContent.focus();
                placeCaretAtEnd(nextContent);
                currentItem = nextContent.closest('.outline-item');
            }
        } else if (e.ctrlKey && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
            e.preventDefault();
            const selection = window.getSelection();
            const range = selection.getRangeAt(0);
            const text = content.textContent;
            const offset = range.startOffset;
            if (e.key === 'ArrowLeft') {
                const prevSpace = text.lastIndexOf(' ', offset - 1);
                const newOffset = prevSpace === -1 ? 0 : prevSpace + 1;
                range.setStart(content.firstChild || content, newOffset);
                range.setEnd(content.firstChild || content, newOffset);
            } else if (e.key === 'ArrowRight') {
                const nextSpace = text.indexOf(' ', offset);
                const newOffset = nextSpace === -1 ? text.length : nextSpace;
                range.setStart(content.firstChild || content, newOffset);
                range.setEnd(content.firstChild || content, newOffset);
            }
            selection.removeAllRanges();
            selection.addRange(range);
        } else if (e.ctrlKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
            e.preventDefault();
            const selection = window.getSelection();
            const range = selection.getRangeAt(0);
            const brs = Array.from(content.querySelectorAll('br'));
            const textNodes = Array.from(content.childNodes).filter(node => node.nodeType === 3 || node.nodeName === 'BR');
            const currentNode = range.startContainer;
            let currentIndex = textNodes.indexOf(currentNode);
            if (currentNode.nodeName === 'BR') currentIndex = textNodes.indexOf(currentNode);

            if (e.key === 'ArrowUp' && currentIndex > 0) {
                const prevNode = textNodes[currentIndex - 1];
                if (prevNode.nodeType === 3) {
                    range.setStart(prevNode, 0);
                    range.setEnd(prevNode, 0);
                } else {
                    range.setStartBefore(prevNode);
                    range.setEndBefore(prevNode);
                }
            } else if (e.key === 'ArrowDown' && currentIndex < textNodes.length - 1) {
                const nextNode = textNodes[currentIndex + 1];
                if (nextNode.nodeType === 3) {
                    range.setStart(nextNode, 0);
                    range.setEnd(nextNode, 0);
                } else {
                    range.setStartAfter(nextNode);
                    range.setEndAfter(nextNode);
                }
            }
            selection.removeAllRanges();
            selection.addRange(range);
        } else if (e.key === 'z' && e.ctrlKey) {
            e.preventDefault();
            undo();
        } else if (e.key === 'y' && e.ctrlKey) {
            e.preventDefault();
            redo();
        } else if (e.key === 'b' && e.ctrlKey) {
            e.preventDefault();
            applyBold();
        } else if (e.key === 'h' && e.ctrlKey && !e.shiftKey) {
            e.preventDefault();
            applyHighlight('yellow');
        } else if (e.key === 'h' && e.ctrlKey && e.shiftKey) {
            e.preventDefault();
            applyHighlight('orange');
        } else if (e.key === 't' && e.ctrlKey) {
            e.preventDefault();
            toggleCheckboxes();
        } else if (e.key === 'f' && e.ctrlKey) {
            e.preventDefault();
            formattingEnabled = !formattingEnabled;
            document.getElementById('toggleFormattingBtn').classList.toggle('active', formattingEnabled);
            updateFormattingMode();
            saveState(formattingEnabled ? 'Enabled Formatting' : 'Disabled Formatting');
        } else if (e.key === 'V' && e.ctrlKey && e.shiftKey) {
            e.preventDefault();
            const asSubItems = currentItem && confirm('Paste as sub-items of the selected item? Click "Cancel" to paste as main items.');
            pasteAsItems(asSubItems);
        }
    });

    function applyColor(color) {
        if (isApplyingColor) return;
        isApplyingColor = true;
        const focusedContent = document.activeElement.closest('.content') || (currentItem && currentItem.querySelector('.content'));
        if (!focusedContent) {
            alert('Please select an item or text to color.');
            isApplyingColor = false;
            return;
        }
        const item = focusedContent.closest('.outline-item');
        currentItem = item;
        const selection = window.getSelection();
        if (selection.rangeCount > 0 && focusedContent.contains(selection.anchorNode)) {
            const range = selection.getRangeAt(0);
            if (!range.collapsed && selection.toString().trim().length > 0) {
                const fragment = range.extractContents();
                const span = document.createElement('span');
                span.style.color = color;
                span.appendChild(fragment);
                range.insertNode(span);
                selection.removeAllRanges();
                focusedContent.focus();
                updateItemHeight(item);
                saveState(`Applied ${color} Color`);
            }
        }
        isApplyingColor = false;
    }

    function applyBold() {
        const focusedContent = document.activeElement.closest('.content') || (currentItem && currentItem.querySelector('.content'));
        if (!focusedContent) {
            alert('Please select an item or text to bold.');
            return;
        }
        const item = focusedContent.closest('.outline-item');
        const selection = window.getSelection();
        if (selection.rangeCount > 0 && focusedContent.contains(selection.anchorNode)) {
            const range = selection.getRangeAt(0);
            if (!range.collapsed) {
                const fragment = range.extractContents();
                const span = document.createElement('span');
                span.style.fontWeight = 'bold';
                span.appendChild(fragment);
                range.insertNode(span);
                selection.removeAllRanges();
                focusedContent.focus();
                updateItemHeight(item);
                saveState('Applied Bold');
            }
        }
    }

    function applyHighlight(color) {
        const focusedContent = document.activeElement.closest('.content') || (currentItem && currentItem.querySelector('.content'));
        if (!focusedContent) {
            alert('Please select an item or text to highlight.');
            return;
        }
        const item = focusedContent.closest('.outline-item');
        const selection = window.getSelection();
        if (selection.rangeCount > 0 && focusedContent.contains(selection.anchorNode)) {
            const range = selection.getRangeAt(0);
            if (!range.collapsed) {
                const fragment = range.extractContents();
                const span = document.createElement('span');
                span.style.backgroundColor = color;
                span.appendChild(fragment);
                range.insertNode(span);
                selection.removeAllRanges();
                focusedContent.focus();
                updateItemHeight(item);
                saveState(`Applied ${color} Highlight`);
            }
        }
    }

    function applyStyle(property, value) {
        const content = currentItem.querySelector('.content');
        const selection = window.getSelection();
        if (selection.rangeCount > 0 && content.contains(selection.anchorNode)) {
            const range = selection.getRangeAt(0);
            if (!range.collapsed) {
                const fragment = range.extractContents();
                const span = document.createElement('span');
                span.style[property] = value;
                span.appendChild(fragment);
                range.insertNode(span);
                selection.removeAllRanges();
                content.focus();
            } else {
                content.style[property] = value;
            }
        } else {
            content.style[property] = value;
        }
        updateItemHeight(currentItem);
        saveState(`Changed ${property} to ${value}`);
    }

    function stripFormatting(e) {
        if (!formattingEnabled) {
            e.preventDefault();
            const text = e.clipboardData.getData('text/plain');
            document.execCommand('insertText', false, text);
        }
    }

    function updateFormattingMode() {
        document.querySelectorAll('.content').forEach(content => {
            if (!formattingEnabled) {
                content.addEventListener('paste', stripFormatting);
            } else {
                content.removeEventListener('paste', stripFormatting);
            }
        });
        document.getElementById('toggleFormattingBtn').classList.toggle('active', formattingEnabled);
    }

function generatePDF(forDownload = false) {
    return new Promise((resolve) => {
        const modal = document.getElementById('orientationModal');
        const portraitBtn = document.getElementById('portraitBtn');
        const landscapeBtn = document.getElementById('landscapeBtn');
        const cancelBtn = document.getElementById('cancelOrientationBtn');
        const closeModalBtn = document.getElementById('closeOrientationModal');
        const fitAllCheckbox = document.getElementById('fitAllCheckbox');

        modal.style.display = 'flex';

        const outlineContainer = document.querySelector('.outline-container');
        const controlsContainer = document.querySelector('.controls-container');
        const resizeBarContainer = document.getElementById('resizeBarContainer');
        const outlineList = document.getElementById('outlineList');
        const resizeHandle = document.querySelector('.resize-handle');
        const statusBar = document.querySelector('.status-bar');
        let tempContainer;

        const proceedWithOrientation = async (orientation) => {
            modal.style.display = 'none';
            if (orientation === null) {
                updateStatus('PDF Generation Cancelled');
                resolve();
                return;
            }

            const fitAll = fitAllCheckbox.checked;
            const doc = new jsPDF({
                orientation: orientation,
                unit: 'mm',
                format: 'a4'
            });

            // Temporarily hide elements we don’t want in the PDF
            controlsContainer.style.display = 'none';
            resizeHandle.style.display = 'none';
            statusBar.style.display = 'none';
            outlineContainer.style.overflow = 'visible';
            outlineList.style.overflow = 'visible';

            // Create a temporary container for just the outline content
            tempContainer = document.createElement('div');
            tempContainer.style.position = 'absolute';
            tempContainer.style.top = '0';
            tempContainer.style.left = '-9999px'; // Off-screen
            tempContainer.style.width = `${outlineContainer.offsetWidth}px`;
            tempContainer.style.background = '#f8fafc';
            tempContainer.style.padding = '15px';
            tempContainer.appendChild(resizeBarContainer.cloneNode(true));
            tempContainer.appendChild(outlineList.cloneNode(true));
            document.body.appendChild(tempContainer);

            const pdfWidth = doc.internal.pageSize.getWidth();
            const pdfHeight = doc.internal.pageSize.getHeight();
            const scale = 2; // Higher resolution
            const contentWidth = tempContainer.offsetWidth;
            const contentHeight = tempContainer.scrollHeight;
            const pageHeightInPixels = (pdfHeight * scale * 96) / 25.4; // mm to pixels at 96 DPI
            const ratio = (pdfWidth * scale * 96 / 25.4) / contentWidth; // Scale to fit width

            if (fitAll) {
                // Multi-page PDF with all content
                async function captureAndAddPages(currentY = 0) {
                    const totalHeight = contentHeight * ratio;
                    if (currentY >= totalHeight) {
                        finalizePDF('Fit All');
                        return;
                    }

                    try {
                        const canvas = await html2canvas(tempContainer, {
                            scale: scale,
                            width: contentWidth,
                            height: Math.min(pageHeightInPixels / ratio, contentHeight - currentY / ratio),
                            y: currentY / ratio,
                            backgroundColor: '#f8fafc',
                            useCORS: true
                        });

                        const imgData = canvas.toDataURL('image/png');
                        const imgWidth = canvas.width;
                        const imgHeight = canvas.height;
                        const scaledWidth = pdfWidth;
                        const scaledHeight = (imgHeight * pdfWidth) / imgWidth;

                        if (currentY > 0) doc.addPage();
                        doc.addImage(imgData, 'PNG', 0, 0, scaledWidth, scaledHeight);

                        await captureAndAddPages(currentY + pageHeightInPixels);
                    } catch (error) {
                        console.error('Error generating PDF:', error);
                        alert('Failed to generate PDF. Check console for details.');
                        cleanup();
                        resolve();
                    }
                }

                await captureAndAddPages();
            } else {
                // Single-page PDF (original behavior)
                try {
                    const canvas = await html2canvas(tempContainer, {
                        scale: scale,
                        useCORS: true,
                        backgroundColor: '#f8fafc'
                    });

                    const imgData = canvas.toDataURL('image/png');
                    const imgWidth = canvas.width;
                    const imgHeight = canvas.height;
                    const ratio = Math.min(pdfWidth / imgWidth, pdfHeight / imgHeight);
                    const scaledWidth = imgWidth * ratio;
                    const scaledHeight = imgHeight * ratio;
                    const xOffset = (pdfWidth - scaledWidth) / 2;
                    const yOffset = (pdfHeight - scaledHeight) / 2;

                    doc.addImage(imgData, 'PNG', xOffset, yOffset, scaledWidth, scaledHeight);
                    finalizePDF('Single Page');
                } catch (error) {
                    console.error('Error generating PDF:', error);
                    alert('Failed to generate PDF. Check console for details.');
                    cleanup();
                    resolve();
                }
            }

            function finalizePDF(mode) {
                cleanup();
                const filename = `${outlineTitle.value || 'outline'}_${orientation}_${mode.toLowerCase().replace(' ', '_')}.pdf`;
                if (forDownload) {
                    doc.save(filename);
                    updateStatus(`Downloaded PDF (${mode}, ${orientation})`);
                } else {
                    const pdfBlob = doc.output('blob');
                    const url = URL.createObjectURL(pdfBlob);
                    window.open(url);
                    updateStatus(`Opened PDF (${mode}, ${orientation})`);
                }
                resolve();
            }

            function cleanup() {
                if (tempContainer && tempContainer.parentNode) {
                    document.body.removeChild(tempContainer);
                }
                controlsContainer.style.display = '';
                resizeHandle.style.display = '';
                statusBar.style.display = '';
                outlineContainer.style.overflow = '';
                outlineList.style.overflow = 'auto';
            }
        };

        portraitBtn.onclick = () => proceedWithOrientation('portrait');
        landscapeBtn.onclick = () => proceedWithOrientation('landscape');
        cancelBtn.onclick = () => proceedWithOrientation(null);
        closeModalBtn.onclick = () => proceedWithOrientation(null);
        modal.onclick = (e) => {
            if (e.target === modal) proceedWithOrientation(null);
        };
    });
}

// Update the existing event listener for pdfOpenBtn
document.getElementById('pdfOpenBtn').addEventListener('click', () => {
    generatePDF(false);
});

// Update the pdfDownloadBtn to use the new function as well
document.getElementById('pdfDownloadBtn').addEventListener('click', () => {
    generatePDF(true);
});
    function exportOPML() {
        const opmlDoc = document.implementation.createDocument('', '', null);
        const opml = opmlDoc.createElement('opml');
        opml.setAttribute('version', '1.0');
        opmlDoc.appendChild(opml);

        const head = opmlDoc.createElement('head');
        const title = opmlDoc.createElement('title');
        title.textContent = outlineTitle.value || 'Outline';
        head.appendChild(title);
        opml.appendChild(head);

        const body = opmlDoc.createElement('body');
        opml.appendChild(body);

        function addOutlineItems(items, parentElement) {
            for (let item of items) {
                const outline = opmlDoc.createElement('outline');
                const content = item.querySelector('.content').textContent.trim() || 'Untitled';
                outline.setAttribute('text', content);
                if (item.classList.contains('hidden')) {
                    outline.setAttribute('expanded', 'no');
                }
                parentElement.appendChild(outline);
                const children = item.querySelector('.outline-list').children;
                if (children.length > 0) {
                    addOutlineItems(children, outline);
                }
            }
        }

        addOutlineItems(outlineList.children, body);

        const serializer = new XMLSerializer();
        const opmlString = serializer.serializeToString(opmlDoc);
        const blob = new Blob([opmlString], { type: 'text/xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${outlineTitle.value || 'outline'}.opml`;
        a.click();
        URL.revokeObjectURL(url);
        updateStatus('Exported OPML');
    }

    function importOPML(file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            const parser = new DOMParser();
            const opmlDoc = parser.parseFromString(event.target.result, 'text/xml');
            const titleElement = opmlDoc.querySelector('head > title');
            outlineTitle.value = titleElement ? titleElement.textContent : 'Untitled Outline';

            const outlines = opmlDoc.querySelectorAll('body > outline');
            outlineList.innerHTML = '';

            function processOutline(outline, level, parentList) {
                const text = outline.getAttribute('text') || '';
                const newItem = createItem(text, level);
                if (outline.getAttribute('expanded') === 'no') {
                    newItem.classList.add('hidden');
                }
                parentList.appendChild(newItem);
                const children = outline.children;
                if (children.length > 0) {
                    const subList = newItem.querySelector('.outline-list');
                    for (let child of children) {
                        if (child.tagName === 'outline') {
                            processOutline(child, level + 1, subList);
                        }
                    }
                }
                updateItemState(newItem);
            }

            outlines.forEach(outline => processOutline(outline, 0, outlineList));
            updateItemStates();
            updateResizeBars();
            currentItem = outlineList.querySelector('.outline-item');
            if (currentItem) currentItem.querySelector('.content').focus();
            saveState('Imported OPML');
        };
        reader.readAsText(file);
    }

    function deleteCurrentItem() {
        if (currentItem) {
            const parentItem = currentItem.parentElement.closest('.outline-item');
            currentItem.remove();
            saveState('Deleted Item');
            currentItem = parentItem || outlineList.querySelector('.outline-item');
            if (currentItem) currentItem.querySelector('.content').focus();
            if (parentItem) updateItemState(parentItem);
            updateResizeBars();
        }
    }

    function placeCaretAtEnd(el) {
        const range = document.createRange();
        const sel = window.getSelection();
        range.selectNodeContents(el);
        range.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range);
        el.focus();
    }

    function updateItemState(item) {
        const parentList = item.parentElement.closest('.outline-list');
        const parentItem = parentList?.parentElement.closest('.outline-item');
        const currentLevel = parentItem ? (parseInt(parentItem.className.match(/level-(\d)/)?.[1] || 0) + 1) : 0;
        item.className = `outline-item${currentLevel > 0 ? ` level-${currentLevel}` : ''}`;
        item.draggable = true;
        const hasChildren = item.querySelector('.outline-list').children.length > 0;
        item.classList.toggle('has-children', hasChildren);

        const toggle = item.querySelector('.no-toggle, .toggle-btn');
        if (hasChildren && toggle.classList.contains('no-toggle')) {
            toggle.className = 'toggle-btn';
            toggle.textContent = item.classList.contains('hidden') ? '▶' : '▼';
        } else if (!hasChildren && toggle.classList.contains('toggle-btn')) {
            toggle.className = 'no-toggle';
            toggle.textContent = '';
        }
        updateItemHeight(item);
    }

    function updateItemStates() {
        document.querySelectorAll('.outline-item').forEach(updateItemState);
    }

    function serializeItems(items) {
        const result = [];
        for (let item of items) {
            const content = item.querySelector('.content');
            const checkbox = item.querySelector('.checkbox');
            const children = item.querySelector('.outline-list').children;
            const level = item.className.match(/level-(\d)/)?.[1] || '0';
            const isHidden = item.classList.contains('hidden');
            const itemData = {
                text: content.innerHTML,
                level: parseInt(level),
                width: content.style.width || `${levelWidths[level]}px`,
                hidden: isHidden,
                children: serializeItems(children)
            };
            if (hasCheckboxes && checkbox) itemData.checked = checkbox.checked;
            result.push(itemData);
        }
        return result;
    }

    function deserializeItems(items, parentList) {
        items.forEach(itemData => {
            const newItem = createItem(itemData.text, itemData.level, itemData.checked || false);
            const content = newItem.querySelector('.content');
            content.innerHTML = itemData.text;
            content.style.width = itemData.width;
            levelWidths[itemData.level] = parseInt(itemData.width) || levelWidths[itemData.level];
            if (itemData.hidden) newItem.classList.add('hidden');
            parentList.appendChild(newItem);
            deserializeItems(itemData.children, newItem.querySelector('.outline-list'));
            updateItemState(newItem);
        });
    }

    function loadJSONFile(file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            const data = JSON.parse(event.target.result);
            outlineTitle.value = data.title || 'Untitled Outline';
            hasCheckboxes = data.hasCheckboxes || false;
            formattingEnabled = data.formattingEnabled || false;
            if (data.levelNames && Array.isArray(data.levelNames)) {
                levelNames.length = 0;
                levelNames.push(...data.levelNames);
            }
            outlineList.innerHTML = '';
            deserializeItems(data.items, outlineList);
            updateItemStates();
            updateResizeBars();
            updateFormattingMode();
            currentItem = outlineList.querySelector('.outline-item');
            if (currentItem) currentItem.querySelector('.content').focus();
            saveState('Loaded File');
        };
        reader.readAsText(file);
    }

    const resizeHandle = document.querySelector('.resize-handle');
    let isResizingContainer = false;
    let containerStartX, containerStartY, containerStartWidth, containerStartHeight;

    resizeHandle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        isResizingContainer = true;
        containerStartX = e.pageX;
        containerStartY = e.pageY;
        containerStartWidth = outlineContainer.offsetWidth;
        containerStartHeight = outlineContainer.offsetHeight;
        document.addEventListener('mousemove', resizeContainer);
        document.addEventListener('mouseup', stopResizeContainer);
    });

    function resizeContainer(e) {
        if (isResizingContainer) {
            const newWidth = Math.max(400, containerStartWidth + (e.pageX - containerStartX));
            const newHeight = Math.max(200, containerStartHeight + (e.pageY - containerStartY));
            outlineContainer.style.width = `${newWidth}px`;
            outlineContainer.style.height = `${newHeight}px`;
            updateStatus(`Resized to ${newWidth}x${newHeight}`);
        }
    }

    function stopResizeContainer() {
        isResizingContainer = false;
        document.removeEventListener('mousemove', resizeContainer);
        document.removeEventListener('mouseup', stopResizeContainer);
        saveState('Resized Frame');
    }

document.addEventListener('DOMContentLoaded', () => {
    const initialItem = outlineList.querySelector('.outline-item');
    if (initialItem) {
        currentItem = initialItem;
        // Attach toggle event listener to the initial item's toggle element
        const toggle = initialItem.querySelector('.no-toggle');
        toggle.addEventListener('click', (e) => {
            e.stopPropagation();
            if (toggle.classList.contains('toggle-btn')) {
                const item = toggle.closest('.outline-item');
                item.classList.toggle('hidden');
                toggle.textContent = item.classList.contains('hidden') ? '▶' : '▼';
            }
        });
        updateItemState(initialItem);
        updateResizeBars();
        updateFormattingMode();
        saveState('Initial Load');
    }
    updateStatus('Loaded');
});

 
</script>
<footer style="text-align: center; color: #6b7280; font-size: 12px; margin-top: 20px;">
    Copyright © 2025 Dr. Wen-Ming Yang <br>
    20250403: v2.15h hierarchy paste items.
    <img src="https://hitwebcounter.com/counter/counter.php?page=20090258&style=0002&nbdigits=5&type=page&initCount=0" title="Counter Widget" Alt="Visit counter For Websites"   border="0" /></a>   
</footer> 
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'92739abd7f51674d',t:'MTc0MzEyNzk2Ni4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>